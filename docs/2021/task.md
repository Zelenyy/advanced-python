# Задачи

1. (_Трансляция программ_) Выберите одну из ваших программ на Python и попробуйте запустить её в альтернативном интерпретаторе (PyPy, Jython, IronPython). Опишите причины почему это не получилось. Если получилось, то сделайте измерения производительности: общее время работы программы с помощью консольной утилиты `time` и время выполнения отдельной части кода с помощью `time.perf_counter()`
2. (_Паттерны проектирование. Магические методы_) Использую метод `__new__` реализуйте паттерн [Singleton](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
3. (_Декораторы_) Напишите декоратор кэширующий вызовы функции в файл: он должен сохранять результаты вызова функции в файл, и в дальнейшем при разных запусках программы он по возможности вместо вычисления функции должен брать результаты из файла.
4. (_Параллелизм_) Выберите две функции: просто производящую вычисления (например, вы можете использовать функцию строящую множество Мандельброта) и функцию выполняющую вычисления и при этом производящую работу с диском (считывающую/записывающую данные на диск) и запустите параллельное выполнение этой функции с помощью `multiprocessing`. Постройте график зависимости времени выполнения от количества одновременно вычисляемых функций, для каждой функции (желательно на многоядерной машине, количество точек примерно x3 от числа логических ядер). Объясните полученные результаты.
5. (_Bitwise Operations_) Некоторый бинарный формат (на самом деле это HDF5), хранит информацию от версии и классе типа данных внутри одного байта, первые четыре бита содержат номер версии, а последние номер класса. Использую битовые операции, напишите функцию которая принимая целое число, а возвращает версию и класс. 
6. (_JSON_) Реализуйте JSON Encoder позволяющий сериализовать numpy record array.
7. (_Matplotlib_) Постройте с помощью Matplotlib:
   1. график отображающий изменение двух величин в разных единицах по оси Y (ось для второй величины расположите с противоположенной стороны графика относительно оси первой величины) 
   2. график для которого подписи метки по оси Y отображаются в процентах (с использованием знака `%` в подписи метки)  
8. (_ORM_, _Декораторы_, _SQLAlchemy_) Напишите декоратор, работающий поверх декоратора `@dataclass` и с помощью SQLAlchemy создающий отображение в базу данных для пользовательского дата-класса.
9. (_Protobuf_, _Магические методы_) Пусть данные в бинарном файле хранятся как набор записей. Запись имеет такой формат:
   * Первые 8 байт содержат число N;
   * Следующие N байт содержат сообщение в формате _protobuf_ (схема сообщения одинакова для всех записей).
   Реализуйте класс позволяющий работать с файлом как со списком _protobuf_ сообщений.
10. (_argparse_, _HDF_, _ROOT_, _ZIP_, _IO_) Напишите скрипт который принимает на вход ZIP архив (используйте `ZipFiles`) и конвертирует содержимое архива в файлы форматов HDF или ROOT (тип выходного файла должен определятся аргументом скрипта, используйте модуль `argparse`). Все файлы в архиве описываются [этим форматом](../../scp-masters/advanced-python/docs/2021/task_10/README_RDM), пример архива лежит [здесь](../../scp-masters/advanced-python/docs/2021/task_10/data.zip). Для работы с HDF используйте модуль `h5py` или `pytables`. Для работы с ROOT используйте `pyROOT` или `uproot`.
11. (_Numba_, _Cython_) Возьми функцию из вашего собственного кода и разгоните её:
    1. с помощью Numba.
    2. c помощью Cython.
12. (_Native extensions_) Запустите из python следующую функцию (способ на ваш выбор: `ctype`, `cffi`, `pyROOT`, `Boost.Python`, `SWIG` и т. д.): 
```c 
void count_pi(double& pi, int count)
{  
    // count --- approximation accuracy of number PI
    int count1;
    double a, b;
    for(count, count1 = 1; count != 0; count--, count1++)
    {
        if(count1 == 1)
        {
            a = 4 - 1;
            b = 1;
            pi = 4/b - 4/a;
        }
        if(count1 > 1)
        {
            a = a + 4;
            b = b + 4;
            pi = pi + (4/b-4/a);
        }   
    }
}
```
13.  (_subprocess_, _scipy_, _numpy IO_)Используя `subprocess.Popen` запустите в вашей командной оболочке команду для получения случайно числовой последовательности и считайте её вывод в ваш скрипт. Проверьте с помощью статистического теста из `scipy.stats` что в полученной последовательность цифры распределены равномерно и сохраните их как numpy массив в файл формата `.npz`.
14. (_USB_, _HID API_, _HTTP_, _WEB_, _Plotly_) Напишите программу, которая считывает данные с выданного вам USB-термометра, и выводит их на WEB-график (для построения графика используйте plotly, для обновления данных используйте модуль http, для чтения данных с термометра доработайте шаблон, который я покажу на лекции)