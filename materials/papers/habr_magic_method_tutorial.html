<!DOCTYPE html>
<html lang="en" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Руководство по магическим методам в Питоне / Habr</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.29e3fe9b.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.1ca41abb.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.b84b16a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.132461d8.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.7ecad03c.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-f458c7c4.529673c8.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.29e3fe9b.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.b84b16a4.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-f458c7c4.7ecad03c.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/en-compiled.bcabb12b60d952c463cc36c729af8034.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({en: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/186608\/"},"headline":"Руководство по магическим методам в Питоне","datePublished":"2013-07-15T13:00:53+04:00","dateModified":"2013-07-17T19:20:43+04:00","author":{"@type":"Person","name":"Сергей Головин"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Это перевод 1.17 версии руководства от Rafe Kettler.   Содержание  Вступление Конструирование и инициализация Переопределение операторов на произвольных классах...","url":"https:\/\/habr.com\/ru\/post\/186608\/#post-content-body","about":["h_python","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/186608\/a399eb2aab51e2620374b39af74c7fc3\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.45.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Руководство по магическим методам в Питоне" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Руководство по магическим методам в Питоне" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Руководство по магическим методам в Питоне" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Это перевод 1.17 версии руководства от Rafe Kettler.


Содержание

Вступление
Конструирование и инициализация
Переопределение операторов на произвольных классах
Магические методы..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Это перевод 1.17 версии руководства от Rafe Kettler.


Содержание

Вступление
Конструирование и инициализация
Переопределение операторов на произвольных классах
Магические методы..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Это перевод 1.17 версии руководства от Rafe Kettler.


Содержание

Вступление
Конструирование и инициализация
Переопределение операторов на произвольных классах
Магические методы..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Это перевод 1.17 версии руководства от Rafe Kettler.


Содержание

Вступление
Конструирование и инициализация
Переопределение операторов на произвольных классах
Магические методы..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Это перевод 1.17 версии руководства от Rafe Kettler.


Содержание

Вступление
Конструирование и инициализация
Переопределение операторов на произвольных классах
Магические методы..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="186608" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2013-07-15T09:00:53.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/en/rss/post/186608/?fl=en" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/186608/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/186608/a399eb2aab51e2620374b39af74c7fc3/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----><div></div><!----><header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----><span class="tm-header__logo-wrap"><a href="/en/" class="tm-header__logo tm-header__logo_en"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Habr</title><use xlink:href="/img/habr-logo-en.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!----><a href="/en/sandbox/start/" class="tm-header__become-author-btn">
              How to become an author
            </a><!----><!----><!----></div></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----><a href="/en/all/" class="tm-main-menu__item">
        All streams
      </a><a href="/en/flows/develop/" class="tm-main-menu__item">
          Development
        </a><a href="/en/flows/admin/" class="tm-main-menu__item">
          Admin
        </a><a href="/en/flows/design/" class="tm-main-menu__item">
          Design
        </a><a href="/en/flows/management/" class="tm-main-menu__item">
          Management
        </a><a href="/en/flows/marketing/" class="tm-main-menu__item">
          Marketing
        </a><a href="/en/flows/popsci/" class="tm-main-menu__item">
          PopSci
        </a></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/en/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Search</title><use xlink:href="/img/megazord-v24.cee85629.svg#search"></use></svg></a><!----><!----><!----><div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Profile</title><use xlink:href="/img/megazord-v24.cee85629.svg#header-user"></use></svg><!----></div><!----></div><!----></div><!----></div></div></div></div><!----><div class="tm-page-width"></div><main class="tm-layout__container"><div hl="en" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----><div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Pull to refresh</title><use xlink:href="/img/megazord-v24.cee85629.svg#pull-arrow"></use></svg></div></div><!----><div class="tm-page-article__body"><article class="tm-page-article__content tm-page-article__content_inner"><div class="tm-page-article__head-wrapper"><!----><div class="tm-article-snippet tm-page-article__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/en/users/begezavr/" title="begezavr" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/dfb/ebc/0ee/dfbebc0ee0ba41a25e30dd308bab1401.jpg" width="24" class="tm-entity-image__pic"></div></a><span class="tm-user-info__user"><a href="/en/users/begezavr/" class="tm-user-info__username">
      begezavr
    </a></span></span><span class="tm-article-snippet__datetime-published"><time datetime="2013-07-15T09:00:53.000Z" title="2013-07-15, 13:00">15  July  2013 at 13:00</time></span></div><!----></div><h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Руководство по магическим методам в Питоне</span></h1><div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/en/hub/python/" class="tm-article-snippet__hubs-item-link"><span>Python</span><span title="Core hub" class="tm-article-snippet__profiled-hub">*</span></a></span></div><div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
          Translation
        </span></div><div class="tm-article-snippet__label"><span>
          Tutorial
        </span></div></div><!----><!----></div></div><div class="tm-page-article__origin"><a href="http://www.rafekettler.com/magicmethods.html" target="_blank" class="tm-page-article__origin-link">
                Original author:
                <span class="tm-page-article__origin-value">
                  Rafe Kettler
                </span></a></div><div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml">Это перевод 1.17 версии <a href="http://www.rafekettler.com/magicmethods.html">руководства</a> от Rafe Kettler.<br/>
<br/>
<br/>
<h2>Содержание</h2><br/>
<ol>
<li><a href="http://habrahabr.ru/post/186608/#intro">Вступление</a></li>
<li><a href="http://habrahabr.ru/post/186608/#construction">Конструирование и инициализация</a></li>
<li><a href="http://habrahabr.ru/post/186608/#operators">Переопределение операторов на произвольных классах</a><ul>
<li><a href="http://habrahabr.ru/post/186608/#comparisons">Магические методы сравнения</a></li>
<li><a href="http://habrahabr.ru/post/186608/#numeric">Числовые магический методы</a></li>
</ul></li>
<li><a href="http://habrahabr.ru/post/186608/#representations">Представление своих классов</a></li>
<li><a href="http://habrahabr.ru/post/186608/#access">Контроль доступа к атрибутам</a></li>
<li><a href="http://habrahabr.ru/post/186608/#sequence">Создание произвольных последовательностей</a></li>
<li><a href="http://habrahabr.ru/post/186608/#reflection">Отражение</a></li>
<li><a href="http://habrahabr.ru/post/186608/#callable">Вызываемые объекты</a></li>
<li><a href="http://habrahabr.ru/post/186608/#context">Менеджеры контекста</a></li>
<li><a href="http://habrahabr.ru/post/186608/#abcs">Абстрактные базовые классы</a> </li>
<li><a href="http://habrahabr.ru/post/186608/#descriptor">Построение дескрипторов</a></li>
<li><a href="http://habrahabr.ru/post/186608/#copying">Копирование</a></li>
<li><a href="http://habrahabr.ru/post/186608/#pickling">Использование модуля pickle на своих объектах</a></li>
<li><a href="http://habrahabr.ru/post/186608/#conclusion">Заключение</a></li>
<li><a href="http://habrahabr.ru/post/186608/#appendix1">Приложение 1: Как вызывать магические методы</a></li>
<li><a href="http://habrahabr.ru/post/186608/#appendix2">Приложение 2: Изменения в Питоне 3</a></li>
</ol><br/>
<br/>
<h2><a name="intro"></a>Вступление</h2><br/>
Что такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, <code>__init__</code> или <code>__lt__</code>). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации.  Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание. Я просто постарался как можно понятнее описать магические методы.<a name="habracut"></a><br/>
<br/>
<br/>
<h2><a name="construction"></a>Конструирование и инициализация.</h2><br/>
Всем известен самый базовый магический метод, <code>__init__</code>. С его помощью мы можем инициализировать объект. Однако, когда я пишу <code>x = SomeClass()</code>, <code>__init__</code> не самое первое, что вызывается. На самом деле, экземпляр объекта создаёт метод <code>__new__</code>, а затем аргументы передаются в инициализатор. На другом конце жизненного цикла объекта находится метод <code>__del__</code>. Давайте подробнее рассмотрим эти три магических метода:<br/>
<br/>
<ul>
<li><code>__new__(cls, [...)</code><br/>
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в <code>__init__</code>. <code>__new__</code> используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. Я не намерен очень детально останавливаться на <code>__new__</code>, так как он не то чтобы очень часто нужен, но этот метод очень хорошо и детально описан в <a href="http://www.python.org/download/releases/2.2/descrintro/#__new__">документации</a>.<br/>
<br/>
</li>
<li><code>__init__(self, [...)</code><br/>
Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем <code>x = SomeClass(10, 'foo')</code>, <code>__init__</code> получит <code>10</code> и <code>'foo'</code> в качестве аргументов. <code>__init__</code> почти повсеместно используется при определении классов.<br/>
<br/>
</li>
<li><code>__del__(self)</code><br/>
Если <code>__new__</code> и <code>__init__</code> образуют конструктор объекта, <code>__del__</code> это его деструктор. Он не определяет поведение для выражения <code>del x</code> (поэтому этот код не эквивалентен <code>x.__del__()</code>). Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты. Однако, нужно быть осторожным, так как нет гарантии, что <code>__del__</code> будет вызван, если объект продолжает жить, когда интерпретатор завершает работу. Поэтому <code>__del__</code> не может служить заменой для хороших программистских практик (всегда завершать соединение, если закончил с ним работать и тому подобное). Фактически, из-за отсутствия гарантии вызова, <code>__del__</code> не должен использоваться почти никогда; используйте его с осторожностью!<br/>
<br/>
<strong>Замечание от переводчика:</strong> <a href="https://habrahabr.ru/users/svetlov/" class="user_link">svetlov</a> <a href="#comment_6492862">отмечает</a>, что здесь автор ошибается, на самом деле <code>__del__</code> всегда вызывается по завершении работы интерпретатора.<br/>
<br/>
</li>
</ul><br/>
Соединим всё вместе, вот пример <code>__init__</code> и <code>__del__</code> в действии:<br/>
<br/>
<pre><code class="python">from os.path import join

class FileObject:
    '''Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.'''

    def __init__(self, filepath='~', filename='sample.txt'):
        # открыть файл filename в filepath в режиме чтения и записи
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file
</code></pre><br/>
<br/>
<h2><a name="operators"></a>Переопределение операторов на произвольных классах</h2><br/>
Одно из больших преимуществ использования магических методов в Питоне то, что они предоставляют простой способ заставить объекты вести себя по подобию встроенных типов. Это означает, что вы можете избежать унылого, нелогичного и нестандартного поведения базовых операторов. В некоторых языках обычное явление писать как-нибудь так:<br/>
<br/>
<pre><code class="python">if instance.equals(other_instance):
    # do something
</code></pre><br/>
Вы, конечно, можете поступать так же и в Питоне, но это добавляет путаницы и ненужной многословности. Разные библиотеки могут по разному называть одни и те же операции, заставляя использующего их программиста совершать больше действий, чем необходимо. Используя силу магических методов, мы можем определить нужный метод (<code>__eq__</code>, в этом случае), и так точно выразить, что мы <em>имели в виду</em>:<br/>
<br/>
<pre><code class="python">if instance == other_instance:
    #do something
</code></pre><br/>
Это одна из сильных сторон магических методов. Подавляющее большинство из них позволяют определить, что будут делать стандартные операторы, так что мы можем использовать операторы на своих классах так, как будто они встроенные типы.<br/>
<br/>
<br/>
<h3><a name="comparisons"></a>Магические методы сравнения</h3><br/>
В Питоне уйма магических методов, созданных для определения интуитивного сравнения между объектами используя операторы, а не неуклюжие методы. Кроме того, они предоставляют способ переопределить поведение Питона по-умолчанию для сравнения объектов (по ссылке). Вот список этих методов и что они делают:<br/>
<br/>
<ul>
<li><code>__cmp__(self, other)</code><br/>
Самый базовый из методов сравнения. Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). <code>__cmp__</code> должен вернуть отрицательное число, если <code>self &lt; other</code>, ноль, если <code>self == other</code>, и положительное число в случае <code>self > other</code>. Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в <code>__cmp__</code>. Но <code>__cmp__</code> может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.<br/>
<br/>
</li>
<li><code>__eq__(self, other)</code><br/>
Определяет поведение оператора равенства, <code>==</code>.<br/>
<br/>
</li>
<li><code>__ne__(self, other)</code><br/>
Определяет поведение оператора неравенства, <code>!=</code>.<br/>
<br/>
</li>
<li><code>__lt__(self, other)</code><br/>
Определяет поведение оператора меньше, <code>&lt;</code>.<br/>
<br/>
</li>
<li><code>__gt__(self, other)</code><br/>
Определяет поведение оператора больше, <code>></code>.<br/>
<br/>
</li>
<li><code>__le__(self, other)</code><br/>
Определяет поведение оператора меньше или равно, <code>&lt;=</code>.<br/>
<br/>
</li>
<li><code>__ge__(self, other)</code><br/>
Определяет поведение оператора больше или равно, <code>>=</code>.<br/>
<br/>
</li>
</ul><br/>
Для примера расммотрим класс, описывающий слово. Мы можем сравнивать слова лексиграфически (по алфавиту), что является дефолтным поведением при сравнении строк, но можем захотеть использовать при сравнении какой-нибудь другой критерий, такой, как длина или количество слогов. В этом примере мы будем сравнивать по длине. Вот реализация:<br/>
<br/>
<pre><code class="python">class Word(str):
    '''Класс для слов, определяющий сравнение по длине слов.'''

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print "Value contains spaces. Truncating to first space."
            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) &lt; len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) &lt;= len(other)
</code></pre><br/>
Теперь мы можем создать два <code>Word</code> (при помощи <code>Word('foo')</code> и <code>Word('bar')</code>) и сравнить их по длине. Заметьте, что мы не определяли <code>__eq__</code> и <code>__ne__</code>, так как это приведёт к странному поведению (например, <code>Word('foo') == Word('bar')</code> будет расцениваться как истина). В этом нет смысла при тестировании на эквивалентность, основанную на длине, поэтому мы оставляем стандартную проверку на эквивалентность от <code>str</code>.<br/>
Сейчас, кажется, удачное время упомянуть, что вы не должны определять каждый из магических методов сравнения, чтобы полностью охватить все сравнения. Стандартная библиотека любезно предоставляет нам класс-декторатор в модуле <code>functools</code>, который и определит все сравнивающие методы, от вас достаточно определить только <code>__eq__</code> и ещё один (<code>__gt__</code>, <code>__lt__</code> и т.п.) Эта возможность доступна начиная с 2.7 версии Питона, но если это вас устраивает, вы сэкономите кучу времени и усилий. Для того, чтобы задействовать её, поместите <code>@total_ordering</code> над вашим определением класса.<br/>
<br/>
<br/>
<h3><a name="numeric"></a>Числовые магические методы</h3><br/>
Точно так же, как вы можете определить, каким образом ваши объекты будут сравниваться операторами сравнения, вы можете определить их поведение для числовых операторов. Приготовтесь, друзья, их много. Для лучшей организации, я разбил числовые магические методы на 5 категорий: унарные операторы, обычные арифметические операторы, отражённые арифметические операторы (подробности позже), составные присваивания и преобразования типов.<br/>
<br/>
<br/>
<h4>Унарные операторы и функции</h4><br/>
Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.<br/>
<br/>
<ul>
<li><code>__pos__(self)</code><br/>
Определяет поведение для унарного плюса (<code>+some_object</code>)<br/>
<br/>
</li>
<li><code>__neg__(self)</code><br/>
Определяет поведение для отрицания(<code>-some_object</code>)<br/>
<br/>
</li>
<li><code>__abs__(self)</code><br/>
Определяет поведение для встроенной функции <code>abs()</code>.<br/>
<br/>
</li>
<li><code>__invert__(self)</code><br/>
Определяет поведение для инвертирования оператором <code>~</code>. Для объяснения что он делает смотри <a href="http://en.wikipedia.org/wiki/Bitwise_operation#NOT">статью в Википедии о бинарных операторах</a>.<br/>
<br/>
</li>
<li><code>__round__(self, n)</code><br/>
Определяет поведение для встроенной функции <code>round()</code>. <code>n</code> это число знаков после запятой, до которого округлить.<br/>
<br/>
</li>
<li><code>__floor__(self)</code><br/>
Определяет поведение для <code>math.floor()</code>, то есть, округления до ближайшего меньшего целого.<br/>
<br/>
</li>
<li><code>__ceil__(self)</code><br/>
Определяет поведение для <code>math.ceil()</code>, то есть, округления до ближайшего большего целого.<br/>
<br/>
</li>
<li><code>__trunc__(self)</code><br/>
Определяет поведение для <code>math.trunc()</code>, то есть, обрезания до целого.<br/>
<br/>
</li>
</ul><br/>
<h4>Обычные арифметические операторы</h4><br/>
Теперь рассмотрим обычные бинарные операторы (и ещё пару функций): +, -, * и похожие. Они, по большей части, отлично сами себя описывают.<br/>
<br/>
<ul>
<li><code>__add__(self, other)</code><br/>
Сложение.<br/>
<br/>
</li>
<li><code>__sub__(self, other)</code><br/>
Вычитание.<br/>
<br/>
</li>
<li><code>__mul__(self, other)</code><br/>
Умножение.<br/>
<br/>
</li>
<li><code>__floordiv__(self, other)</code><br/>
Целочисленное деление, оператор <code>//</code>.<br/>
<br/>
</li>
<li><code>__div__(self, other)</code><br/>
Деление, оператор <code>/</code>.<br/>
<br/>
</li>
<li><code>__truediv__(self, other)</code><br/>
<em>Правильное</em> деление. Заметьте, что это работает только когда используется <code>from __future__ import division</code>.<br/>
<br/>
</li>
<li><code>__mod__(self, other)</code><br/>
Остаток от деления, оператор <code>%</code>.<br/>
<br/>
</li>
<li><code>__divmod__(self, other)</code><br/>
Определяет поведение для встроенной функции <code>divmod()</code>.<br/>
<br/>
</li>
<li><code>__pow__</code><br/>
Возведение в степень, оператор <code>**</code>.<br/>
<br/>
</li>
<li><code>__lshift__(self, other)</code><br/>
Двоичный сдвиг влево, оператор <code>&lt;&lt;</code>.<br/>
<br/>
</li>
<li><code>__rshift__(self, other)</code><br/>
Двоичный сдвиг вправо, оператор <code>>></code>.<br/>
<br/>
</li>
<li><code>__and__(self, other)</code><br/>
Двоичное И, оператор <code>&amp;</code>.<br/>
<br/>
</li>
<li><code>__or__(self, other)</code><br/>
Двоичное ИЛИ, оператор <code>|</code>.<br/>
<br/>
</li>
<li><code>__xor__(self, other)</code><br/>
Двоичный xor, оператор <code>^</code>.<br/>
<br/>
</li>
</ul><br/>
<h4>Отражённые арифметические операторы</h4><br/>
Помните как я сказал, что собираюсь остановиться на отражённой арифметике подробнее? Вы могли подумать, что это какая-то большая, страшная и непонятная концепция. На самом деле всё очень просто. Вот пример:<br/>
<br/>
<pre><code class="python">some_object + other
</code></pre><br/>
Это «обычное» сложение. Единственное, чем отличается эквивалентное отражённое выражение, это порядок слагаемых:<br/>
<br/>
<pre><code class="python">other + some_object
</code></pre><br/>
Таким образом, все эти магические методы делают то же самое, что и их обычные версии, за исключением выполнения операции с <code>other</code> в качестве первого операнда и <code>self</code> в качестве второго. В большинстве случаев, результат отражённой операции такой же, как её обычный эквивалент, поэтому при определении <code>__radd__</code> вы можете ограничиться вызовом <code>__add__</code> да и всё. Заметьте, что объект слева от оператора (<code>other</code> в примере) не должен иметь обычной неотражённой версии этого метода. В нашем примере, <code>some_object.__radd__</code> будет вызван только если в <code>other</code> не определён <code>__add__</code>.<br/>
<br/>
<ul>
<li><code>__radd__(self, other)</code><br/>
Отражённое сложение.<br/>
<br/>
</li>
<li><code>__rsub__(self, other)</code><br/>
Отражённое вычитание.<br/>
<br/>
</li>
<li><code>__rmul__(self, other)</code><br/>
Отражённое умножение.<br/>
<br/>
</li>
<li><code>__rfloordiv__(self, other)</code><br/>
Отражённое целочисленное деление, оператор <code>//</code>.<br/>
<br/>
</li>
<li><code>__rdiv__(self, other)</code><br/>
Отражённое деление, оператор <code>/</code>.<br/>
<br/>
</li>
<li><code>__rtruediv__(self, other)</code><br/>
Отражённое <em>правильное</em> деление. Заметьте, что работает только когда используется <code>from __future__ import division</code>.<br/>
<br/>
</li>
<li><code>__rmod__(self, other)</code><br/>
Отражённый остаток от деления, оператор <code>%</code>.<br/>
<br/>
</li>
<li><code>__rdivmod__(self, other)</code><br/>
Определяет поведение для встроенной функции <code>divmod()</code>, когда вызывается <code>divmod(other, self)</code>.<br/>
<br/>
</li>
<li><code>__rpow__</code><br/>
Отражённое возведение в степерь, оператор <code>**</code>.<br/>
<br/>
</li>
<li><code>__rlshift__(self, other)</code><br/>
Отражённый двоичный сдвиг влево, оператор <code>&lt;&lt;</code>.<br/>
<br/>
</li>
<li><code>__rrshift__(self, other)</code><br/>
Отражённый двоичный сдвиг вправо, оператор <code>>></code>.<br/>
<br/>
</li>
<li><code>__rand__(self, other)</code><br/>
Отражённое двоичное И, оператор <code>&amp;</code>.<br/>
<br/>
</li>
<li><code>__ror__(self, other)</code><br/>
Отражённое двоичное ИЛИ, оператор <code>|</code>.<br/>
<br/>
</li>
<li><code>__rxor__(self, other)</code><br/>
Отражённый двоичный xor, оператор <code>^</code>.<br/>
<br/>
<br/>
</li>
</ul><h4>Составное присваивание</h4><br/>
В Питоне широко представлены и магические методы для составного присваивания. Вы скорее всего уже знакомы с составным присваиванием, это комбинация «обычного» оператора и присваивания. Если всё ещё непонятно, вот пример:<br/>
<br/>
<pre><code class="python">x = 5
x += 1 # другими словами x = x + 1
</code></pre><br/>
Каждый из этих методов должен возвращать значение, которое будет присвоено переменной слева (например, для <code>a += b</code>, <code>__iadd__</code> должен вернуть <code>a + b</code>, что будет присвоено <code>a</code>). Вот список:<br/>
<br/>
<ul>
<li><code>__iadd__(self, other)</code><br/>
Сложение с присваиванием.<br/>
<br/>
</li>
<li><code>__isub__(self, other)</code><br/>
Вычитание с присваиванием.<br/>
<br/>
</li>
<li><code>__imul__(self, other)</code><br/>
Умножение с присваиванием.<br/>
<br/>
</li>
<li><code>__ifloordiv__(self, other)</code><br/>
Целочисленное деление с присваиванием, оператор <code>//=</code>.<br/>
<br/>
</li>
<li><code>__idiv__(self, other)</code><br/>
Деление с присваиванием, оператор <code>/=</code>.<br/>
<br/>
</li>
<li><code>__itruediv__(self, other)</code><br/>
<em>Правильное</em> деление с присваиванием. Заметьте, что работает только если используется <code>from __future__ import division</code>.<br/>
<br/>
</li>
<li><code>__imod_(self, other)</code><br/>
Остаток от деления с присваиванием, оператор <code>%=</code>.<br/>
<br/>
</li>
<li><code>__ipow__</code><br/>
Возведение в степерь с присваиванием, оператор <code>**=</code>.<br/>
<br/>
</li>
<li><code>__ilshift__(self, other)</code><br/>
Двоичный сдвиг влево с присваиванием, оператор <code>&lt;&lt;=</code>.<br/>
<br/>
</li>
<li><code>__irshift__(self, other)</code><br/>
Двоичный сдвиг вправо с присваиванием, оператор <code>>>=</code>.<br/>
<br/>
</li>
<li><code>__iand__(self, other)</code><br/>
Двоичное И с присваиванием, оператор <code>&amp;=</code>.<br/>
<br/>
</li>
<li><code>__ior__(self, other)</code><br/>
Двоичное ИЛИ с присваиванием, оператор <code>|=</code>.<br/>
<br/>
</li>
<li><code>__ixor__(self, other)</code><br/>
Двоичный xor с присваиванием, оператор <code>^=</code>.<br/>
<br/>
<br/>
</li>
</ul><h4>Магические методы преобразования типов</h4><br/>
Кроме того, в Питоне множество магических методов, предназначенных для определния поведения для встроенных функций преобразования типов, таких как <code>float()</code>. Вот они все:<br/>
<br/>
<ul>
<li><code>__int__(self)</code><br/>
Преобразование типа в int.<br/>
<br/>
</li>
<li><code>__long__(self)</code><br/>
Преобразование типа в long.<br/>
<br/>
</li>
<li><code>__float__(self)</code><br/>
Преобразование типа в float.<br/>
<br/>
</li>
<li><code>__complex__(self)</code><br/>
Преобразование типа в комплексное число.<br/>
<br/>
</li>
<li><code>__oct__(self)</code><br/>
Преобразование типа в восьмеричное число.<br/>
<br/>
</li>
<li><code>__hex__(self)</code><br/>
Преобразование типа в шестнадцатиричное число.<br/>
<br/>
</li>
<li><code>__index__(self)</code><br/>
Преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]). Если вы определяете свой числовый тип, который может использоваться как индекс списка, вы должны определить <code>__index__</code>.<br/>
<br/>
</li>
<li><code>__trunc__(self)</code><br/>
Вызывается при <code>math.trunc(self)</code>. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).<br/>
<br/>
</li>
<li><code>__coerce__(self, other)</code><br/>
Метод для реализации арифметики с операндами разных типов. <code>__coerce__</code> должен вернуть <code>None</code> если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из <code>self</code> и <code>other</code>, преобразованные к одному типу.<br/>
<br/>
</li>
</ul><br/>
<h2><a name="representations"></a>Представление своих классов</h2><br/>
Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.<br/>
<br/>
<ul>
<li><code>__str__(self)</code><br/>
Определяет поведение функции <code>str()</code>, вызванной для экземпляра вашего класса.<br/>
<br/>
</li>
<li><code>__repr__(self)</code><br/>
Определяет поведение функции <code>repr()</code>, вызыванной для экземпляра вашего класса. Главное отличие от <code>str()</code> в целевой аудитории. <code>repr()</code> больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а <code>str()</code> предназначен для чтения людьми.<br/>
<br/>
</li>
<li><code>__unicode__(self)</code><br/>
Определяет поведение функции <code>unicode()</code>, вызыванной для экземпляра вашего класса. <code>unicode()</code> похож на <code>str()</code>, но возвращает строку в юникоде. Будте осторожны: если клиент вызывает <code>str()</code> на экземпляре вашего класса, а вы определили только <code>__unicode__()</code>, то это не будет работать. Постарайтесь всегда определять <code>__str__()</code> для случая, когда кто-то не имеет такой роскоши как юникод.<br/>
<br/>
</li>
<li><code>__format__(self, formatstr)</code><br/>
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, <code>"Hello, {0:abc}!".format(a)</code> приведёт к вызову <code>a.__format__("abc")</code>. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.<br/>
<br/>
</li>
<li><code>__hash__(self)</code><br/>
Определяет поведение функции <code>hash()</code>, вызыванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и <code>__eq__</code> тоже. Руководствуйтесь следующим правилом: <code>a == b</code> подразумевает <code>hash(a) == hash(b)</code>.<br/>
<br/>
</li>
<li><code>__nonzero__(self)</code><br/>
Определяет поведение функции <code>bool()</code>, вызванной для экземпляра вашего класса. Должна вернуть True или False, в зависимости от того, когда вы считаете экземпляр соответствующим True или False.<br/>
<br/>
</li>
<li><code>__dir__(self)</code><br/>
Определяет поведение функции <code>dir()</code>, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение <code>__dir__</code> не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили <code>__getattr__</code> или <code>__getattribute__</code> (с которыми вы встретитесь в следующей части), или каким-либо другим образом динамически создаёте атрибуты.<br/>
<br/>
</li>
<li><code>__sizeof__(self)</code><br/>
Определяет поведение функции <code>sys.getsizeof()</code>, вызыванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах. Он главным образом полезен для классов, определённых в расширениях на C, но всё-равно полезно о нём знать.<br/>
<br/>
</li>
</ul><br/>
Мы почти закончили со скучной (и лишённой примеров) частью руководства по магическим методам. Теперь, когда мы рассмотрели самые базовые магические методы, пришло время перейти к более продвинутому материалу.<br/>
<br/>
<br/>
<h2><a name="access"></a>Контроль доступа к атрибутам</h2><br/>
Многие люди, пришедшие в Питон из других языков, жалуются на отсутствие настоящей инкапсуляции для классов (например, нет способа определить приватные атрибуты с публичными методами доступа). Это не совсем правда: просто многие вещи, связанные с инкапсуляцией, Питон реализует через «магию», а не явными модификаторами для методов и полей. Смотрите:<br/>
<br/>
<ul>
<li><code>__getattr__(self, name)</code><br/>
Вы можете определить поведение для случая, когда пользователь пытается обратиться к атрибуту, который не существует (совсем или пока ещё). Это может быть полезным для перехвата и перенаправления частых опечаток, предупреждения об использовании устаревших атрибутов (вы можете всё-равно вычислить и вернуть этот атрибут, если хотите), или хитро возвращать <code>AttributeError</code>, когда это вам нужно. Правда, этот метод вызывается только когда пытаются получить доступ к несуществующему атрибуту, поэтому это не очень хорошее решение для инкапсуляции.<br/>
<br/>
</li>
<li><code>__setattr__(self, name, value)</code><br/>
В отличии от <code>__getattr__</code>, <code>__setattr__</code> решение для инкапсуляции. Этот метод позволяет вам определить поведение для присвоения значения атрибуту, независимо от того существует атрибут или нет. То есть, вы можете определить любые правила для любых изменений значения атрибутов. Впрочем, вы должны быть осторожны с тем, как использовать <code>__setattr__</code>, смотрите пример нехорошего случая в конце этого списка.<br/>
<br/>
</li>
<li><code>__delattr__</code><br/>
Это то же, что и <code>__setattr__</code>, но для удаления атрибутов, вместо установки значений. Здесь требуются те же меры предосторожности, что и в <code>__setattr__</code> чтобы избежать бесконечной рекурсии (вызов <code>del self.name</code> в определении <code>__delattr__</code> вызовет бесконечную рекурсию).<br/>
<br/>
</li>
<li><code>__getattribute__(self, name)</code><br/>
<code>__getattribute__</code> выглядит к месту среди своих коллег <code>__setattr__</code> и <code>__delattr__</code>, но я бы не рекомендовал вам его использовать. <code>__getattribute__</code> может использоваться только с классами нового типа (в новых версиях Питона все классы нового типа, а в старых версиях вы можете получить такой класс унаследовавшись от <code>object</code>). Этот метод позволяет вам определить поведение для <em>каждого</em> случая доступа к атрибутам (а не только к несуществующим, как <code>__getattr__(self, name)</code>). Он страдает от таких же проблем с бесконечной рекурсией, как и его коллеги (на этот раз вы можете вызывать <code>__getattribute__</code> у базового класса, чтобы их предотвратить). Он, так же, главным образом устраняет необходимость в <code>__getattr__</code>, который в случае реализации <code>__getattribute__</code> может быть вызван только явным образом или в случае генерации исключения <code>AttributeError</code>. Вы конечно можете использовать этот метод (в конце концов, это ваш выбор), но я бы не рекомендовал, потому что случаев, когда он действительно полезен очень мало (намного реже нужно переопределять поведение при получении, а не при установке значения) и реализовать его без возможных ошибок очень сложно.<br/>
<br/>
</li>
</ul><br/>
Вы можете запросто получить проблему при определении любого метогда, управляющего доступом к атрибутам. Рассмотрим пример:<br/>
<br/>
<pre><code class="python">def __setattr__(self, name, value):
    self.name = value
    # это рекурсия, так как всякий раз, когда любому атрибуту присваивается значение,
    # вызывается  __setattr__().
    # тоесть, на самом деле это равнозначно self.__setattr__('name', value). 
    # Так как метод вызывает сам себя, рекурсия продолжится бесконечно, пока всё не упадёт

def __setattr__(self, name, value):
    self.__dict__[name] = value # присваивание в словарь переменных класса
    # дальше определение произвольного поведения
</code></pre><br/>
Ещё раз, мощь магических методов в Питоне невероятна, а с большой силой приходит и большая ответственность. Важно знать, как правильно использовать магические методы, ничего не ломая.<br/>
<br/>
Итак, что мы узнали об управлении доступом к атрибутам? Их не нужно использовать легкомысленно. На самом деле, они имеют склонность к чрезмерной мощи и нелогичности. Причина, по которой они всё-таки существуют, в удволетворении определённого желания: Питон склонен не запрещать плохие штуки полностью, а только усложнять их использование. Свобода первостепенна, поэтому вы на самом деле можете делать всё, что хотите. Вот пример использования методов контроля доступа (заметьте, что мы используем <code>super</code>, так как не все классы имеют атрибут <code>__dict__</code>):<br/>
<br/>
<pre><code class="python">class AccessCounter(object):
    '''Класс, содержащий атрибут value и реализующий счётчик доступа к нему.
    Счётчик увеличивается каждый раз, когда меняется value.'''

    def __init__(self, val):
        super(AccessCounter, self).__setattr__('counter', 0)
        super(AccessCounter, self).__setattr__('value', val)

    def __setattr__(self, name, value):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        # Не будем делать здесь никаких условий.
        # Если вы хотите предотвратить изменение других атрибутов,
        # выбросьте исключение AttributeError(name)
        super(AccessCounter, self).__setattr__(name, value)

    def __delattr__(self, name):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        super(AccessCounter, self).__delattr__(name)]
</code></pre><br/>
<br/>
<h2><a name="sequence"></a>Создание произвольных последовательностей</h2><br/>
В Питоне существует множество способов заставить ваши классы вести себя как встроенные последовательности (словари, кортежи, списки, строки и так далее). Это, безусловно, мои любимые магические методы, из-за до абсурда высокой степени контроля, которую они дают и той магии, от которой с экземплярами ваших классов вдруг начинает прекрасно работать целое множество глобальных функций. Но, до того как мы перейдём ко всяким хорошим вещам, мы должны знать о протоколах.<br/>
<br/>
<br/>
<h4>Протоколы</h4><br/>
Теперь, когда речь зашла о создании собственных последовательностей в Питоне, пришло время поговорить о <em>протоколах</em>. Протоколы немного похожи на интерфейсы в других языках тем, что они предоставляют набор методов, которые вы должны реализовать. Однако, в Питоне протоколы абсолютно ни к чему не обязывают и не требуют обязательно реализовать какое-либо объявление. Наверное, они больше похожи на руководящие указания.<br/>
<br/>
Почему мы заговорили о протоколах? Потому, что реализация произвольных контейнерных типов в Питоне влечёт за собой использование некоторых из них. Во-первых, протокол для определения неизменяемых контейнеров: чтобы создать неизменяемый контейнер, вы должны только определить <code>__len__</code> и <code>__getitem__</code> (продробнее о них дальше). Протокол изменяемого контейнера требует того же, что и неизменяемого контейнера, плюс <code>__setitem__</code> и <code>__delitem__</code>. И, наконец, если вы хотите, чтобы ваши объекты можно было перебирать итерацией, вы должны определить <code>__iter__</code>, который возвращает итератор. Этот итератор должен соответствовать протоколу итератора, который требует методов <code>__iter__</code>(возвращает самого себя) и <code>next</code>.<br/>
<br/>
<br/>
<h4>Магия контейнеров</h4><br/>
Без дальнейшего промедления, вот магические методы, используемые контейнерами:<br/>
<br/>
<ul>
<li><code>__len__(self)</code><br/>
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.<br/>
<br/>
</li>
<li><code>__getitem__(self, key)</code><br/>
Определяет поведение при доступе к элементу, используя синтаксис <code>self[key]</code>. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: <code>TypeError</code> если неправильный тип ключа и <code>KeyError</code> если ключу не соответствует никакого значения.<br/>
<br/>
</li>
<li><code>__setitem__(self, key, value)</code><br/>
Определяет поведение при присваивании значения элементу, используя синтаксис <code>self[nkey] = value</code>. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать <code>KeyError</code> и <code>TypeError</code> в соответсвующих случаях.<br/>
<br/>
</li>
<li><code>__delitem__(self, key)</code><br/>
Определяет поведение при удалении элемента (то есть <code>del self[key]</code>). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.<br/>
<br/>
</li>
<li><code>__iter__(self)</code><br/>
Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции <code>iter()</code> и в случае перебора элементов контейнера выражением <code>for x in container:</code>. Итераторы сами по себе объекты и они тоже должны определять метод <code>__iter__</code>, который возвращает <code>self</code>.<br/>
<br/>
</li>
<li><code>__reversed__(self)</code><br/>
Вызывается чтобы определить поведения для встроенной функции <code>reversed()</code>. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.<br/>
<br/>
</li>
<li><code>__contains__(self, item)</code><br/>
<code>__contains__</code> предназначен для проверки принадлежности элемента с помощью <code>in</code> и <code>not in</code>. Вы спросите, почему же это не часть протокола последовательности? Потому что когда <code>__contains__</code> не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает <code>True</code> если находит нужный.<br/>
<br/>
</li>
<li><code>__missing__(self, key)</code><br/>
<code>__missing__</code> используется при наследовании от <code>dict</code>. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь <code>d</code> и я пишу <code>d["george"]</code> когда <code>"george"</code> не является ключом в словаре, вызывается <code>d.__missing__("george")</code>).<br/>
<br/>
</li>
</ul><br/>
<h4>Пример</h4><br/>
Для примера, давайте посмотрим на список, который реализует некоторые функциональные конструкции, которые вы могли встретить в других языках (Хаскеле, например).<br/>
<br/>
<pre><code class="python">class FunctionalList:
    '''Класс-обёртка над списком с добавлением некоторой функциональной магии: head,
    tail, init, last, drop, take.'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        # если значение или тип ключа некорректны, list выбросит исключение
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return FunctionalList(reversed(self.values))

    def append(self, value):
        self.values.append(value)
    def head(self):
        # получить первый элемент
        return self.values[0]
    def tail(self):
        # получить все элементы после первого
        return self.values[1:]
    def init(self):
        # получить все элементы кроме последнего
        return self.values[:-1]
    def last(self):
        # получить последний элемент
        return self.values[-1]
    def drop(self, n):
        # все элементы кроме первых n
        return self.values[n:]
    def take(self, n):
        # первые n элементов
        return self.values[:n]
</code></pre><br/>
Теперь у вас есть полезный (относительно) пример реализации своей собственной последовательности. Существуют, конечно, и куда более практичные реализации произвольных последовательностей, но большое их число уже реализовано в стандартной библиотеке (с батарейками в комплекте, да?), такие как <code>Counter</code>, <code>OrderedDict</code>, <code>NamedTuple</code>.<br/>
<br/>
<br/>
<h2><a name="reflection"></a>Отражение</h2><br/>
Вы можете контролировать и отражение, использующее встроенные функции <code>isinstance()</code> и <code>issubclass()</code>, определив некоторые магические методы. Вот они:<br/>
<br/>
<ul>
<li><code>__instancecheck__(self, instance)</code><br/>
Проверяет, является ли экземлпяр членом вашего класса (<code>isinstance(instance, class)</code>, например.<br/>
<br/>
</li>
<li><code>__subclasscheck__(self, subclass)</code><br/>
Проверяет, является наследуется ли класс от вашего класса (<code>issubclass(subclass, class)</code>).<br/>
<br/>
</li>
</ul><br/>
Может показаться, что вариантов полезного использования этих магических методов немного и, возможно, это на самом деле так. Я не хочу тратить слишком много времени на магические методы отражения, не особо они и важные, но они отражают кое-что важное об объектно-ориентированном программировании в Питоне и о Питоне вообще: почти всегда существует простой способ что-либо сделать, даже если надобность в этом «что-либо» возникает очень редко. Эти магические методы могут не выглядеть полезными, но если они вам когда-нибудь понадобятся, вы будете рады вспомнить, что они есть (и для этого вы читаете настоящее руководство!).<br/>
<br/>
<br/>
<h2><a name="callable"></a>Вызываемые объекты</h2><br/>
Как вы наверное уже знаете, в Питоне функции являются объектами первого класса. Это означает, что они могут быть переданы в функции или методы так же, как любые другие объекты. Это невероятно мощная особенность.<br/>
<br/>
Специальный магический метод позволяет экземплярам вашего класса вести себя так, как будто они функции, тоесть вы сможете «вызывать» их, передавать их в функции, которые принимают функции в качестве аргументов и так далее. Это другая удобная особенность, которая делает программирование на Питоне таким приятным.<br/>
<br/>
<ul>
<li><code>__call__(self, [args...])</code><br/>
Позволяет любому экземпляру вашего класса быть вызванным как-будто он функция. Главным образом это означает, что <code>x()</code> означает то же, что и <code>x.__call__()</code>. Заметьте, <code>__call__</code> принимает произвольное число аргументов; то есть, вы можете определить <code>__call__</code> так же как любую другую функцию, принимающую столько аргументов, сколько вам нужно.<br/>
<br/>
</li>
</ul><br/>
<code>__call__</code>, в частности, может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. «Вызвать» экземпляр может быть интуитивно понятным и элегантным способом изменить состояние объекта. Примером может быть класс, представляющий положение некоторого объекта на плоскости:<br/>
<br/>
<pre><code class="python">class Entity:
    '''Класс, описывающий объект на плоскости. "Вызываемый", чтобы обновить позицию объекта.'''

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Изменить положение объекта.'''
        self.x, self.y = x, y

    # чик...
</code></pre><br/>
<br/>
<h2><a name="context"></a>Менеджеры контекста</h2><br/>
В Питоне 2.5 было представлено новое ключевое слово вместе с новым способом повторно использовать код, ключевое слово <code>with</code>. Концепция менеджеров контекста не являлась новой для Питона (она была реализована раньше как часть библиотеки), но в <a href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a> достигла статуса языковой конструкции. Вы могли уже видеть выражения с <code>with</code>:<br/>
<br/>
<pre><code class="python">with open('foo.txt') as bar:
    # выполнение каких-нибудь действий с bar
</code></pre><br/>
Менеджеры контекста позволяют выполнить какие-то действия для настройки или очистки, когда создание объекта обёрнуто в оператор <code>with</code>. Поведение менеджера контекста определяется двумя магическими методами:<br/>
<br/>
<ul>
<li><code>__enter__(self)</code><br/>
Определяет, что должен сделать менеджер контекста в начале блока, созданного оператором <code>with</code>. Заметьте, что возвращаемое <code>__enter__</code> значение и есть то значение, с которым производится работа внутри <code>with</code>.<br/>
<br/>
</li>
<li><code>__exit__(self, exception_type, exception_value, traceback)</code><br/>
Определяет действия менеджера контекста после того, как блок будет выполнен (или прерван во время работы). Может использоваться для контроллирования исключений, чистки, любых действий которые должны быть выполнены незамедлительно после блока внутри with. Если блок выполнен успешно, <code>exception_type</code>, <code>exception_value</code>, и <code>traceback</code> будут установлены в <code>None</code>. В другом случае вы сами выбираете, перехватывать ли исключение или предоставить это пользователю; если вы решили перехватить исключение, убедитесь, что <code>__exit__</code> возвращает <code>True</code> после того как всё сказано и сделано. Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.<br/>
<br/>
</li>
</ul><br/>
<code>__enter__</code> и <code>__exit__</code> могут быть полезны для специфичных классов с хорошо описанным и распространённым поведением для их настройки и очистки ресурсов. Вы можете использовать эти методы и для создания общих менеджеров контекста для разных объектов. Вот пример:<br/>
<br/>
<pre><code class="python">class Closer:
    '''Менеджер контекста для автоматического закрытия объекта вызовом метода close 
    в with-выражении.'''

    def __init__(self, obj):
        self.obj = obj

    def __enter__(self):
        return self.obj # привязка к активному объекту with-блока

    def __exit__(self, exception_type, exception_val, trace):
        try:
           self.obj.close()
        except AttributeError: # у объекта нет метода close
           print 'Not closable.'
           return True # исключение перехвачено
</code></pre><br/>
Пример использования <code>Closer</code> с FTP-соединением (сокет, имеющий метод close):<br/>
<br/>
<pre><code class="python">>>> from magicmethods import Closer
>>> from ftplib import FTP
>>> with Closer(FTP('ftp.somesite.com')) as conn:
...     conn.dir()
...
# output omitted for brevity
>>> conn.dir()
# long AttributeError message, can't use a connection that's closed
>>> with Closer(int(5)) as i:
...     i += 1
...
Not closable.
>>> i
6
</code></pre><br/>
Видите, как наша обёртка изящно управляется и с правильными и с неподходящими объектами. В этом сила менеджеров контекста и магических методов. Заметьте, что стандартная библиотека Питона включает модуль <a href="http://docs.python.org/library/contextlib.html">contextlib</a>, который включает в себя <code>contextlib.closing()</code> — менеджер контекста, который делает приблизительно то же (без какой-либо обработки случая, когда объект не имеет метода <code>close()</code>).<br/>
<br/>
<br/>
<h2><a name="abcs"></a>Абстрактные базовые классы</h2><br/>
Смотри <a href="http://docs.python.org/2/library/abc.html">http://docs.python.org/2/library/abc.html</a>.<br/>
<br/>
<br/>
<h2><a name="descriptor"></a>Построение дескрипторов</h2><br/>
Дескрипторы это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).<br/>
<br/>
Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из <code>__get__</code>, <code>__set__</code> или <code>__delete__</code>. Давайте рассмотрим эти магические методы:<br/>
<br/>
<ul>
<li><code>__get__(self, instance, instance_class)</code><br/>
Определяет поведение при возвращении значения из дескриптора. <code>instance</code> это объект, для чьего атрибута-дескриптора вызывается метод. <code>owner</code> это тип (класс) объекта.<br/>
<br/>
</li>
<li><code>__set__(self, instance, value)</code><br/>
Определяет поведение при изменении значения из дескриптора. <code>instance</code> это объект, для чьего атрибута-дескриптора вызывается метод. <code>value</code> это значение для установки в дескриптор.<br/>
<br/>
</li>
<li><code>__delete__(self, instance)</code><br/>
Определяет поведение для удаления значения из дескриптора. <code>instance</code> это объект, владеющий дескриптором.<br/>
<br/>
</li>
</ul><br/>
Теперь пример полезного использования дескрипторов: преобразование единиц измерения.<br/>
<br/>
<pre><code class="python">class Meter(object):
    '''Дескриптор для метра.'''

    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)

class Foot(object):
    '''Дескриптор для фута.'''

    def __get__(self, instance, owner):
        return instance.meter * 3.2808
    def __set__(self, instance, value):
        instance.meter = float(value) / 3.2808

class Distance(object):
    '''Класс, описывающий расстояние, содержит два дескриптора для футов и
    метров.'''
    meter = Meter()
    foot = Foot()
</code></pre><br/>
<br/>
<h2><a name="copying"></a>Копирование</h2><br/>
В Питоне оператор присваивания не копирует объекты, а только добавляет ещё одну ссылку. Но для коллекций, содержащих изменяемые элементы, иногда необходимо полноценное копирование, чтобы можно было менять элементы одной последовательности, не затрагивая другую. Здесь в игру и вступает <a href="http://docs.python.org/library/copy.html"><code>copy</code></a>. К счастью, модули в Питоне не обладают разумом, поэтому мы можем не беспокоиться что они вдруг начнут бесконтрольно копировать сами себя и вскоре линуксовые роботы заполонят всю планету, но мы должны сказать Питону как правильно копировать.<br/>
<br/>
<ul>
<li><code>__copy__(self)</code><br/>
Определяет поведение <code>copy.copy()</code> для экземпляра вашего класса. <code>copy.copy()</code> возвращает <em>поверхностную копию</em> вашего объекта — это означает, что хоть сам объект и создан заново, все его данные ссылаются на данные оригинального объекта. И при изменении данных нового объекта, изменения будут происходить и в оригинальном.<br/>
<br/>
</li>
<li><code>__deepcopy__(self, memodict={})</code><br/>
Определяет поведение <code>copy.deepcopy()</code> для экземпляров вашего класса. <code>copy.deepcopy()</code> возвращает <em>глубокую копию</em> вашего объекта — копируются и объект <em>и</em> его данные. <code>memodict</code> это кэш предыдущих скопированных объектов, он предназначен для оптимизации копирования и предотвращения бесконечной рекурсии, когда копируются рекурсивные структуры данных. Когда вы хотите полностью скопировать какой-нибудь конкретный атрибут, вызовите на нём <code>copy.deepcopy()</code> с первым параметром <code>memodict</code>.<br/>
<br/>
</li>
</ul><br/>
Когда использовать эти магические методы? Как обычно — в любом случае, когда вам необходимо больше, чем стандартное поведение. Например, если вы пытаетесь скопировать объект, который содержит кэш как словарь (возможно, очень большой словарь), то может быть вам и не нужно копировать весь кэш, а обойтись всего одним в общей памяти объектов.<br/>
<br/>
<br/>
<h2><a name="pickling"></a>Использование модуля pickle на своих объектах</h2><br/>
Pickle это модуль для сериализации структур данных Питона и он может быть невероятно полезен, когда вам нужно сохранить состояние какого-либо объекта и восстановить его позже (обычно, в целях кэширования). Кроме того, это ещё и отличный источник переживаний и путаницы.<br/>
<br/>
Сериализация настолько важна, что кроме своего модуля (<code>pickle</code>) имеет и свой собственный <em>протокол</em> и свои магические методы. Но для начала о том, как сериализовать с помощью pickle уже существующие типы данных (спокойно пропускайте, если вы уже знаете).<br/>
<br/>
<br/>
<h3>Вкратце про сериализацию</h3><br/>
Давайте погрузимся в сериализацию. Допустим, у вас есть словарь, который вы хотите сохранить и восстановить позже. Вы должны записать его содержимое в файл, тщательно убедившись, что пишете с правильным синтаксисом, потом восстановить его, или выполнив <code>exec()</code>, или прочитав файл. Но это в лучшем случае рискованно: если вы храните важные данные в тексте, он может быть повреждён или изменён множеством способов, с целью обрушить вашу программу или, вообще, запустить какой-нибудь опасный код на вашем компьютере. Лучше использовать pickle:<br/>
<br/>
<pre><code class="python">import pickle

data = {'foo': [1, 2, 3],
        'bar': ('Hello', 'world!'),
        'baz': True}
jar = open('data.pkl', 'wb')
pickle.dump(data, jar) # записать сериализованные данные в jar
jar.close()
</code></pre><br/>
И вот, спустя несколько часов, нам снова нужен наш словарь:<br/>
<br/>
<pre><code class="python">import pickle

pkl_file = open('data.pkl', 'rb') # открываем
data = pickle.load(pkl_file) # сохраняем в переменную
print data
pkl_file.close()
</code></pre><br/>
Что произошло? Точно то, что и ожидалось. <code>data</code> как-будто всегда тут и была.<br/>
<br/>
Теперь, немного об осторожности: pickle не идеален. Его файлы легко испортить случайно или преднамеренно. Pickle, может быть, безопаснее чем текстовые файлы, но он всё ещё может использоваться для запуска вредоносного кода. Кроме того, он несовместим между разными версиями Питона, поэтому если вы будете распространять свои объекты с помощью pickle, не ожидайте что все люди смогут их использовать. Тем не менее, модуль может быть мощным инструментом для кэширования и других распространённых задач с сериализацией.<br/>
<br/>
<br/>
<h3>Сериализация собственных объектов.</h3><br/>
Модуль pickle не только для встроенных типов. Он может использоваться с каждым классом, реализующим его протокол. Этот протокол содержит четыре необязательных метода, позволяющих настроить то, как pickle будет с ними обращаться (есть некоторые различия для расширений на C, но это за рамками нашего руководства):<br/>
<br/>
<ul>
<li><code>__getinitargs__(self)</code><br/>
Если вы хотите, чтобы после десериализации вашего класса был вызыван <code>__init__</code>, вы можете определить <code>__getinitargs__</code>, который должен вернуть кортеж аргументов, который будет отправлен в <code>__init__</code>. Заметьте, что этот метод работает только с классами старого стиля.<br/>
<br/>
</li>
<li><code>__getnewargs__(self)</code><br/>
Для классов нового стиля вы можете определить, какие параметры будут переданы в <code>__new__</code> во время десериализации. Этот метод так же должен вернуть кортеж аргументов, которые будут отправлены в <code>__new__</code>.<br/>
<br/>
</li>
<li><code>__getstate__(self)</code><br/>
Вместо стандартного атрибута <code>__dict__</code>, где хранятся атрибуты класса, вы можете вернуть произвольные данные для сериализации. Эти данные будут переданы в <code>__setstate__</code> во время десериализации.<br/>
<br/>
</li>
<li><code>__setstate__(self, state)</code><br/>
Если во время десериализации определён <code>__setstate__</code>, то данные объекта будут переданы сюда, вместо того чтобы просто записать всё в <code>__dict__</code>. Это парный метод для <code>__getstate__</code>: когда оба определены, вы можете представлять состояние вашего объекта так, как вы только захотите.<br/>
<br/>
</li>
<li><code>__reduce__(self)</code><br/>
Если вы определили свой тип (с помощью Python's C API), вы должны сообщить Питону как его сериализовать, если вы хотите, чтобы он его сериализовал. <code>__reduce__()</code> вызывается когда сериализуется объект, в котором этот метод был определён. Он должен вернуть или строку, содержащую имя глобальной переменной, содержимое которой сериализуется как обычно, или кортеж. Кортеж может содержать от 2 до 5 элементов: вызываемый объект, который будет вызван, чтобы создать десериализованный объект, кортеж аргументов для этого вызываемого объекта, данные, которые будут переданы в <code>__setstate__</code> (опционально), итератор списка элементов для сериализации (опционально) и итератор словаря элементов для сериализации (опционально).<br/>
<br/>
</li>
<li><code>__reduce_ex__(self, protocol)</code><br/>
Иногда полезно знать версию протокола, реализуя <code>__reduce__</code>. И этого можно добиться, реализовав вместо него <code>__reduce_ex__</code>. Если <code>__reduce_ex__</code> реализован, то предпочтение при вызове отдаётся ему (вы всё-равно должны реализовать <code>__reduce__</code> для обратной совместимости).<br/>
<br/>
</li>
</ul><br/>
<h3>Пример</h3><br/>
Для примера опишем грифельную доску (<code>Slate</code>), которая запоминает что и когда было на ней записано. Впрочем, конкретно эта доска становится чистой каждый раз, когда она сериализуется: текущее значение не сохраняется.<br/>
<br/>
<pre><code class="python">import time

class Slate:
    '''Класс, хранящий строку и лог изменений. И забывающий своё значение после 
    сериализации.'''

    def __init__(self, value):
        self.value = value
        self.last_change = time.asctime()
        self.history = {}

    def change(self, new_value):
        # Изменить значение. Зафиксировать последнее значение в истории. 
        self.history[self.last_change] = self.value
        self.value = new_value
        self.last_change = time.asctime()

    def print_changes(self):
        print 'Changelog for Slate object:'
        for k, v in self.history.items():
            print '%s\t %s' % (k, v)

    def __getstate__(self):
        # Намеренно не возвращаем self.value or self.last_change.
        # Мы хотим "чистую доску" после десериализации.
        return self.history

    def __setstate__(self, state):
        self.history = state
        self.value, self.last_change = None, None
</code></pre><br/>
<br/>
<h2><a name="conclusion"></a>Заключение</h2><br/>
Цель этого руководства донести что-нибудь до каждого, кто его читает, независимо от его опыта в Питоне или объектно-ориентированном программировании. Если вы новичок в Питоне, вы получили ценные знания об основах написания функциональных, элегантных и простых для использования классов. Если вы программист среднего уровня, то вы, возможно, нашли несколько новых приятных идей и стратегий, несколько хороших способов уменьшить количество кода, написанного вами и вашими клиентами. Если же вы Питонист-эксперт, то вы обновили некоторые свои, возможно, подзабытые знания, а может и нашли парочку новых трюков. Независимо от вашего уровня, я надеюсь, что это путешествие через специальные питоновские методы было поистине магическим (не смог удержаться).<br/>
<br/>
<br/>
<h2><a name="appendix1"></a>Дополнение 1: Как вызывать магические методы</h2><br/>
Некоторые из магических методов напрямую связаны со встроенными функциями; в этом случае совершенно очевидно как их вызывать. Однако, так бывает не всегда. Это дополнение посвящено тому, чтобы раскрыть неочевидный синтаксис, приводящий к вызову магических методов.<br/>
<table>
<thead>
<tr>
<th>Магический метод</th>
<th>Когда он вызывается (пример)</th>
<th>Объяснение</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__new__(cls [,...])</code></td>
<td><code>instance = MyClass(arg1, arg2)</code></td>
<td><code>__new__</code> вызывается при создании экземпляра</td>
</tr>
<tr>
<td><code>__init__(self [,...])</code></td>
<td><code>instance = MyClass(arg1, arg2)</code></td>
<td><code>__init__</code> вызывается при создании экземпляра</td>
</tr>
<tr>
<td><code>__cmp__(self, other)</code></td>
<td><code>self == other</code>, <code>self > other</code>, etc.</td>
<td>Вызывается для любого сравнения</td>
</tr>
<tr>
<td><code>__pos__(self)</code></td>
<td><code>+self</code></td>
<td>Унарный знак плюса</td>
</tr>
<tr>
<td><code>__neg__(self)</code></td>
<td><code>-self</code></td>
<td>Унарный знак минуса</td>
</tr>
<tr>
<td><code>__invert__(self)</code></td>
<td><code>~self</code></td>
<td>Побитовая инверсия</td>
</tr>
<tr>
<td><code>__index__(self)</code></td>
<td><code>x[self]</code></td>
<td>Преобразование, когда объект используется как индекс</td>
</tr>
<tr>
<td><code>__nonzero__(self)</code></td>
<td><code>bool(self)</code>, <code>if self:</code></td>
<td>Булевое значение объекта</td>
</tr>
<tr>
<td><code>__getattr__(self, name)</code></td>
<td><code>self.name # name не определено</code></td>
<td>Пытаются получить несуществующий атрибут</td>
</tr>
<tr>
<td><code>__setattr__(self, name, val)</code></td>
<td><code>self.name = val</code></td>
<td>Присвоение любому атрибуту</td>
</tr>
<tr>
<td><code>__delattr__(self, name)</code></td>
<td><code>del self.name</code></td>
<td>Удаление атрибута</td>
</tr>
<tr>
<td><code>__getattribute__(self, name)</code></td>
<td><code>self.name</code></td>
<td>Получить любой атрибут</td>
</tr>
<tr>
<td><code>__getitem__(self, key)</code></td>
<td><code>self[key]</code></td>
<td>Получение элемента через индекс</td>
</tr>
<tr>
<td><code>__setitem__(self, key, val)</code></td>
<td><code>self[key] = val</code></td>
<td>Присвоение элементу через индекс</td>
</tr>
<tr>
<td><code>__delitem__(self, key)</code></td>
<td><code>del self[key]</code></td>
<td>Удаление элемента через индекс</td>
</tr>
<tr>
<td><code>__iter__(self)</code></td>
<td><code>for x in self</code></td>
<td>Итерация</td>
</tr>
<tr>
<td><code>__contains__(self, value)</code></td>
<td><code>value in self</code>, <code>value not in self</code></td>
<td>Проверка принадлежности с помощью <code>in</code></td>
</tr>
<tr>
<td><code>__call__(self [,...])</code></td>
<td><code>self(args)</code></td>
<td>«Вызов» экземпляра</td>
</tr>
<tr>
<td><code>__enter__(self)</code></td>
<td><code>with self as x:</code></td>
<td><code>with</code> оператор менеджеров контекста</td>
</tr>
<tr>
<td><code>__exit__(self, exc, val, trace)</code></td>
<td><code>with self as x:</code></td>
<td><code>with</code> оператор менеджеров контекста</td>
</tr>
<tr>
<td><code>__getstate__(self)</code></td>
<td><code>pickle.dump(pkl_file, self)</code></td>
<td>Сериализация</td>
</tr>
<tr>
<td><code>__setstate__(self)</code></td>
<td><code>data = pickle.load(pkl_file)</code></td>
<td>Сериализация</td>
</tr>
</tbody>
</table><br/>
<br/>
Надеюсь, эта таблица избавит вас от любых вопросов о том, что за синтаксис вызова магических методов.<br/>
<br/>
<br/>
<h2><a name="appendix2"></a>Дополнение 2: Изменения в Питоне 3</h2><br/>
Опишем несколько главных случаев, когда Питон 3 отличается от 2.x в терминах его объектной модели:<br/>
<br/>
<ul>
<li>Так как в Питоне 3 различий между строкой и юникодом больше нет, <code>__unicode__</code> исчез, а появился <code>__bytes__</code> (который ведёт себя так же как <code>__str__</code> и <code>__unicode__</code> в 2.7) для новых встроенных функций построения байтовых массивов.</li>
<li>Так как деление в Питоне 3 теперь по-умолчанию «правильное деление», <code>__div__</code> больше нет.</li>
<li><code>__coerce__</code> больше нет, из-за избыточности и странного поведения.</li>
<li><code>__cmp__</code> больше нет, из-за избыточности.</li>
<li><code>__nonzero__</code> было переименовано в <code>__bool__</code>.</li>
<li><code>next</code> у итераторов был <a href="http://www.python.org/dev/peps/pep-3114/">переименован</a> в <code>__next__</code>.</li>
</ul><br/>
<br/>
</div></div><!----><!----></div><div class="tm-article-body__tags"><div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Tags:</span><span class="tm-article-body__tags-item"><a href="/en/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpython%5D" class="tm-article-body__tags-item-link">python</a></span><span class="tm-article-body__tags-item"><a href="/en/search/?target_type=posts&amp;order=relevance&amp;q=%5Bmagic%20methods%5D" class="tm-article-body__tags-item-link">magic methods</a></span></div><div class="tm-article-body__tags-links"><span class="tm-article-body__tags-title">Hubs:</span><span class="tm-article-body__tags-item"><a href="/en/hub/python/" class="tm-article-body__tags-item-link">
                  Python
                </a></span></div></div></article><div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Total votes 143: ↑139 and ↓4</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg><span title="Total votes 143: ↑139 and ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+135</span></div><DIV class="v-portal" style="display:none;"></DIV></div><!----><!----><button title="Add to bookmarks" type="button" class="bookmarks-button tm-data-icons__item"><span title="Add to bookmarks" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Add to bookmarks</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span><span title="Users added post to bookmarks" class="bookmarks-button__counter">
    1524
  </span></button><div title="Read comments" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/en/post/186608/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Comments</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">
      59
    </span></a><!----></div><div title="Share" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button><!----></div><DIV class="v-portal" style="display:none;"></DIV></div></div><!----></div><!----><div class="tm-page-article__additional-blocks"><!----><section class="tm-block tm-block_spacing-bottom"><!----><div class="tm-block__body"><div class="tm-article-author tm-page-article__author"><!----><div class="tm-user-card tm-article-author__user-card tm-user-card_variant-two-column"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/en/users/begezavr/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/dfb/ebc/0ee/dfbebc0ee0ba41a25e30dd308bab1401.jpg" class="tm-entity-image__pic"></div></a><div class="tm-user-card__meta"><div title=" 71 votes " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    44.6
  </div><div class="tm-karma__text">
    Karma
  </div></div><div title="User`s rating" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"><div class="tm-rating__counter">0</div></div><div class="tm-rating__text">
    Rating
  </div></div></div></div></div><div class="tm-user-card__info"><div class="tm-user-card__title"><span class="tm-user-card__name">Сергей Головин</span><a href="/en/users/begezavr/" class="tm-user-card__nickname">
          @begezavr
        </a><!----></div><p class="tm-user-card__short-info">Разработчик</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-two-column"><!----><!----><!----><!----><!----></div></div><!----></div></div><!----></section><div class="tm-page-article__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/en/post/186608/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Comments</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Comments 59 
    </span></a><!----></div></div></div><div class="tm-ad-banner__container tm-page-article__banner"><!----><div id="articleBottomBanner" class="tm-ad-banner"></div></div><section class="tm-block tm-block_spacing-around"><header class="tm-block__header"><h2 class="tm-block__title">Popular right now</h2><!----></header><div class="tm-block__body"><ul class="tm-article-list-block__list"><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-06-14T14:35:26.000Z" title="2021-06-14, 17:35">14  June   at 17:35</time></div></div><h2 class="tm-article-title tm-article-title_block"><a href="/en/post/562690/" class="tm-article-title__link"><span>[Tutorial] How to set up Atom IDE for python development</span></a></h2><div class="tm-data-icons"><!----><div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Total votes 3: ↑3 and ↓0</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg><span title="Total votes 3: ↑3 and ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+3</span></div><span title="Views" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Views</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg><span class="tm-icon-counter__value">1.2K</span></span><button title="Add to bookmarks" type="button" class="bookmarks-button tm-data-icons__item"><span title="Add to bookmarks" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Add to bookmarks</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span><span title="Users added post to bookmarks" class="bookmarks-button__counter">
    1
  </span></button><div title="Read comments" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/en/post/562690/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Comments</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">
      1
    </span></a><!----></div><!----><DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2021-02-24T07:31:26.000Z" title="2021-02-24, 10:31">24  February   at 10:31</time></div></div><h2 class="tm-article-title tm-article-title_block"><a href="/en/company/pvs-studio/blog/543868/" class="tm-article-title__link"><span>Free Heroes of Might and Magic II: Open-Source Project that You Want to Be Part of</span></a></h2><div class="tm-data-icons"><!----><div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Total votes 6: ↑6 and ↓0</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg><span title="Total votes 6: ↑6 and ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+6</span></div><span title="Views" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Views</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg><span class="tm-icon-counter__value">3.1K</span></span><button title="Add to bookmarks" type="button" class="bookmarks-button tm-data-icons__item"><span title="Add to bookmarks" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Add to bookmarks</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span><span title="Users added post to bookmarks" class="bookmarks-button__counter">
    0
  </span></button><div title="Read comments" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/en/company/pvs-studio/blog/543868/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Comments</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">
      0
    </span></a><!----></div><!----><DIV class="v-portal" style="display:none;"></DIV></div></article></li><li class="tm-article-list-block__item"><article class="tm-article-snippet-block-block tm-article-snippet-block-block_preview"><div class="tm-article-snippet-block__user-meta"><div class="tm-article-snippet-block__date"><time datetime="2020-11-03T06:02:41.000Z" title="2020-11-03, 09:02">3  November  2020 at 09:02</time></div></div><h2 class="tm-article-title tm-article-title_block"><a href="/en/post/526002/" class="tm-article-title__link"><span>Making python's dream of multithreading come true</span></a></h2><div class="tm-data-icons"><!----><div class="tm-votes-meter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_small"><title>Total votes 4: ↑4 and ↓0</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-rating"></use></svg><span title="Total votes 4: ↑4 and ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_small">+4</span></div><span title="Views" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Views</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-views"></use></svg><span class="tm-icon-counter__value">3.3K</span></span><button title="Add to bookmarks" type="button" class="bookmarks-button tm-data-icons__item"><span title="Add to bookmarks" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Add to bookmarks</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-favorite"></use></svg></span><span title="Users added post to bookmarks" class="bookmarks-button__counter">
    3
  </span></button><div title="Read comments" class="tm-article-comments-counter-link tm-data-icons__item"><a href="/en/post/526002/comments/" class="tm-article-comments-counter-link__link"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon"><title>Comments</title><use xlink:href="/img/megazord-v24.cee85629.svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">
      0
    </span></a><!----></div><!----><DIV class="v-portal" style="display:none;"></DIV></div></article></li><!----></ul></div><!----></section><!----><!----><!----><!----><!----></div></div></div><div class="tm-page__sidebar"><div hl="en" id="186608" class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----><div id="sidebarBanner" class="tm-ad-banner"></div></div></div><div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----></div></div></div></div></div></div></main><!----></div><div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Your account
        </h3><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/en/post/186608/&amp;hl=en" target="_self">
                Log in
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/en/post/186608/&amp;hl=en" target="_self">
                Sign up
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Sections
        </h3><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/en/" class="footer-menu__item-link router-link-active">
                Posts
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/news/" class="footer-menu__item-link">
                News
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/hubs/" class="footer-menu__item-link">
                Hubs
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/companies/" class="footer-menu__item-link">
                Companies
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/users/" class="footer-menu__item-link">
                Authors
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/sandbox/" class="footer-menu__item-link">
                Sandbox
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Information
        </h3><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/en/docs/help/" class="footer-menu__item-link">
                How it works
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/docs/authors/codex/" class="footer-menu__item-link">
                For authors
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/docs/companies/corpblogs/" class="footer-menu__item-link">
                For companies
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/docs/docs/transparency/" class="footer-menu__item-link">
                Documents
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Agreement
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Confidential
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Services
        </h3><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Ads
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Subscription plans
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Content
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Seminars
              </a></li><li class="tm-footer-menu__list-item"><a href="/en/megaprojects/" class="footer-menu__item-link">
                Megaprojects
              </a></li></ul></div></div></div></div></div><div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----><div class="tm-footer__social"><a href="https://www.facebook.com/habr.eng" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title><use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_eng" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title><use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://t.me/habr_eng" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title><use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a></div><DIV class="v-portal" style="display:none;"></DIV><button class="tm-footer__link"><!---->
        Language settings
      </button><a href="/en/about" class="tm-footer__link">
        About
      </a><a href="/en/feedback/" class="tm-footer__link">
        Support
      </a><!----><a href="/berserk-mode-nope" class="tm-footer__link">
        Return to old version
      </a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span><span class="tm-copyright__name">«<a href="https://company.habr.com/en/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div><!----><!----></div><div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"186608":{"id":"186608","timePublished":"2013-07-15T09:00:53+00:00","isCorporative":false,"lang":"ru","titleHtml":"Руководство по магическим методам в Питоне","leadData":{"textHtml":"Это перевод 1.17 версии \u003Ca href=\"http:\u002F\u002Fwww.rafekettler.com\u002Fmagicmethods.html\"\u003Eруководства\u003C\u002Fa\u003E от Rafe Kettler.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСодержание\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#intro\"\u003EВступление\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#construction\"\u003EКонструирование и инициализация\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#operators\"\u003EПереопределение операторов на произвольных классах\u003C\u002Fa\u003E\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#comparisons\"\u003EМагические методы сравнения\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#numeric\"\u003EЧисловые магический методы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#representations\"\u003EПредставление своих классов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#access\"\u003EКонтроль доступа к атрибутам\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#sequence\"\u003EСоздание произвольных последовательностей\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#reflection\"\u003EОтражение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#callable\"\u003EВызываемые объекты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#context\"\u003EМенеджеры контекста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#abcs\"\u003EАбстрактные базовые классы\u003C\u002Fa\u003E \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#descriptor\"\u003EПостроение дескрипторов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#copying\"\u003EКопирование\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#pickling\"\u003EИспользование модуля pickle на своих объектах\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#conclusion\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#appendix1\"\u003EПриложение 1: Как вызывать магические методы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#appendix2\"\u003EПриложение 2: Изменения в Питоне 3\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"intro\"\u003E\u003C\u002Fa\u003EВступление\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЧто такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, \u003Ccode\u003E__init__\u003C\u002Fcode\u003E или \u003Ccode\u003E__lt__\u003C\u002Fcode\u003E). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации.  Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание. Я просто постарался как можно понятнее описать магические методы.","imageUrl":null,"buttonTextHtml":"Читать дальше","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Rafe Kettler","originalUrl":"http:\u002F\u002Fwww.rafekettler.com\u002Fmagicmethods.html"}},{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":44.6,"votesCount":71},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"35523","alias":"begezavr","fullname":"Сергей Головин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fdfb\u002Febc\u002F0ee\u002Fdfbebc0ee0ba41a25e30dd308bab1401.jpg","speciality":"Разработчик"},"statistics":{"commentsCount":59,"favoritesCount":1524,"readingCount":322923,"score":135,"votesCount":143},"hubs":[{"relatedData":null,"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Development"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003EЭто перевод 1.17 версии \u003Ca href=\"http:\u002F\u002Fwww.rafekettler.com\u002Fmagicmethods.html\"\u003Eруководства\u003C\u002Fa\u003E от Rafe Kettler.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСодержание\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#intro\"\u003EВступление\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#construction\"\u003EКонструирование и инициализация\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#operators\"\u003EПереопределение операторов на произвольных классах\u003C\u002Fa\u003E\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#comparisons\"\u003EМагические методы сравнения\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#numeric\"\u003EЧисловые магический методы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#representations\"\u003EПредставление своих классов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#access\"\u003EКонтроль доступа к атрибутам\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#sequence\"\u003EСоздание произвольных последовательностей\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#reflection\"\u003EОтражение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#callable\"\u003EВызываемые объекты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#context\"\u003EМенеджеры контекста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#abcs\"\u003EАбстрактные базовые классы\u003C\u002Fa\u003E \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#descriptor\"\u003EПостроение дескрипторов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#copying\"\u003EКопирование\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#pickling\"\u003EИспользование модуля pickle на своих объектах\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#conclusion\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#appendix1\"\u003EПриложение 1: Как вызывать магические методы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F186608\u002F#appendix2\"\u003EПриложение 2: Изменения в Питоне 3\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"intro\"\u003E\u003C\u002Fa\u003EВступление\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЧто такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, \u003Ccode\u003E__init__\u003C\u002Fcode\u003E или \u003Ccode\u003E__lt__\u003C\u002Fcode\u003E). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации.  Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание. Я просто постарался как можно понятнее описать магические методы.\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"construction\"\u003E\u003C\u002Fa\u003EКонструирование и инициализация.\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВсем известен самый базовый магический метод, \u003Ccode\u003E__init__\u003C\u002Fcode\u003E. С его помощью мы можем инициализировать объект. Однако, когда я пишу \u003Ccode\u003Ex = SomeClass()\u003C\u002Fcode\u003E, \u003Ccode\u003E__init__\u003C\u002Fcode\u003E не самое первое, что вызывается. На самом деле, экземпляр объекта создаёт метод \u003Ccode\u003E__new__\u003C\u002Fcode\u003E, а затем аргументы передаются в инициализатор. На другом конце жизненного цикла объекта находится метод \u003Ccode\u003E__del__\u003C\u002Fcode\u003E. Давайте подробнее рассмотрим эти три магических метода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__new__(cls, [...)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЭто первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в \u003Ccode\u003E__init__\u003C\u002Fcode\u003E. \u003Ccode\u003E__new__\u003C\u002Fcode\u003E используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. Я не намерен очень детально останавливаться на \u003Ccode\u003E__new__\u003C\u002Fcode\u003E, так как он не то чтобы очень часто нужен, но этот метод очень хорошо и детально описан в \u003Ca href=\"http:\u002F\u002Fwww.python.org\u002Fdownload\u002Freleases\u002F2.2\u002Fdescrintro\u002F#__new__\"\u003Eдокументации\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__init__(self, [...)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nИнициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем \u003Ccode\u003Ex = SomeClass(10, 'foo')\u003C\u002Fcode\u003E, \u003Ccode\u003E__init__\u003C\u002Fcode\u003E получит \u003Ccode\u003E10\u003C\u002Fcode\u003E и \u003Ccode\u003E'foo'\u003C\u002Fcode\u003E в качестве аргументов. \u003Ccode\u003E__init__\u003C\u002Fcode\u003E почти повсеместно используется при определении классов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__del__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЕсли \u003Ccode\u003E__new__\u003C\u002Fcode\u003E и \u003Ccode\u003E__init__\u003C\u002Fcode\u003E образуют конструктор объекта, \u003Ccode\u003E__del__\u003C\u002Fcode\u003E это его деструктор. Он не определяет поведение для выражения \u003Ccode\u003Edel x\u003C\u002Fcode\u003E (поэтому этот код не эквивалентен \u003Ccode\u003Ex.__del__()\u003C\u002Fcode\u003E). Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты. Однако, нужно быть осторожным, так как нет гарантии, что \u003Ccode\u003E__del__\u003C\u002Fcode\u003E будет вызван, если объект продолжает жить, когда интерпретатор завершает работу. Поэтому \u003Ccode\u003E__del__\u003C\u002Fcode\u003E не может служить заменой для хороших программистских практик (всегда завершать соединение, если закончил с ним работать и тому подобное). Фактически, из-за отсутствия гарантии вызова, \u003Ccode\u003E__del__\u003C\u002Fcode\u003E не должен использоваться почти никогда; используйте его с осторожностью!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EЗамечание от переводчика:\u003C\u002Fstrong\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fsvetlov\u002F\" class=\"user_link\"\u003Esvetlov\u003C\u002Fa\u003E \u003Ca href=\"#comment_6492862\"\u003Eотмечает\u003C\u002Fa\u003E, что здесь автор ошибается, на самом деле \u003Ccode\u003E__del__\u003C\u002Fcode\u003E всегда вызывается по завершении работы интерпретатора.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nСоединим всё вместе, вот пример \u003Ccode\u003E__init__\u003C\u002Fcode\u003E и \u003Ccode\u003E__del__\u003C\u002Fcode\u003E в действии:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efrom os.path import join\n\nclass FileObject:\n    '''Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.'''\n\n    def __init__(self, filepath='~', filename='sample.txt'):\n        # открыть файл filename в filepath в режиме чтения и записи\n        self.file = open(join(filepath, filename), 'r+')\n\n    def __del__(self):\n        self.file.close()\n        del self.file\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"operators\"\u003E\u003C\u002Fa\u003EПереопределение операторов на произвольных классах\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nОдно из больших преимуществ использования магических методов в Питоне то, что они предоставляют простой способ заставить объекты вести себя по подобию встроенных типов. Это означает, что вы можете избежать унылого, нелогичного и нестандартного поведения базовых операторов. В некоторых языках обычное явление писать как-нибудь так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eif instance.equals(other_instance):\n    # do something\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВы, конечно, можете поступать так же и в Питоне, но это добавляет путаницы и ненужной многословности. Разные библиотеки могут по разному называть одни и те же операции, заставляя использующего их программиста совершать больше действий, чем необходимо. Используя силу магических методов, мы можем определить нужный метод (\u003Ccode\u003E__eq__\u003C\u002Fcode\u003E, в этом случае), и так точно выразить, что мы \u003Cem\u003Eимели в виду\u003C\u002Fem\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eif instance == other_instance:\n    #do something\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто одна из сильных сторон магических методов. Подавляющее большинство из них позволяют определить, что будут делать стандартные операторы, так что мы можем использовать операторы на своих классах так, как будто они встроенные типы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E\u003Ca name=\"comparisons\"\u003E\u003C\u002Fa\u003EМагические методы сравнения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВ Питоне уйма магических методов, созданных для определения интуитивного сравнения между объектами используя операторы, а не неуклюжие методы. Кроме того, они предоставляют способ переопределить поведение Питона по-умолчанию для сравнения объектов (по ссылке). Вот список этих методов и что они делают:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__cmp__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nСамый базовый из методов сравнения. Он, в действительности, определяет поведение для всех операторов сравнения (\u003E, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). \u003Ccode\u003E__cmp__\u003C\u002Fcode\u003E должен вернуть отрицательное число, если \u003Ccode\u003Eself &lt; other\u003C\u002Fcode\u003E, ноль, если \u003Ccode\u003Eself == other\u003C\u002Fcode\u003E, и положительное число в случае \u003Ccode\u003Eself \u003E other\u003C\u002Fcode\u003E. Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в \u003Ccode\u003E__cmp__\u003C\u002Fcode\u003E. Но \u003Ccode\u003E__cmp__\u003C\u002Fcode\u003E может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__eq__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора равенства, \u003Ccode\u003E==\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ne__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора неравенства, \u003Ccode\u003E!=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__lt__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора меньше, \u003Ccode\u003E&lt;\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__gt__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора больше, \u003Ccode\u003E\u003E\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__le__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора меньше или равно, \u003Ccode\u003E&lt;=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ge__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение оператора больше или равно, \u003Ccode\u003E\u003E=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nДля примера расммотрим класс, описывающий слово. Мы можем сравнивать слова лексиграфически (по алфавиту), что является дефолтным поведением при сравнении строк, но можем захотеть использовать при сравнении какой-нибудь другой критерий, такой, как длина или количество слогов. В этом примере мы будем сравнивать по длине. Вот реализация:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Word(str):\n    '''Класс для слов, определяющий сравнение по длине слов.'''\n\n    def __new__(cls, word):\n        # Мы должны использовать __new__, так как тип str неизменяемый\n        # и мы должны инициализировать его раньше (при создании)\n        if ' ' in word:\n            print \"Value contains spaces. Truncating to first space.\"\n            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела\n        return str.__new__(cls, word)\n\n    def __gt__(self, other):\n        return len(self) \u003E len(other)\n    def __lt__(self, other):\n        return len(self) &lt; len(other)\n    def __ge__(self, other):\n        return len(self) \u003E= len(other)\n    def __le__(self, other):\n        return len(self) &lt;= len(other)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь мы можем создать два \u003Ccode\u003EWord\u003C\u002Fcode\u003E (при помощи \u003Ccode\u003EWord('foo')\u003C\u002Fcode\u003E и \u003Ccode\u003EWord('bar')\u003C\u002Fcode\u003E) и сравнить их по длине. Заметьте, что мы не определяли \u003Ccode\u003E__eq__\u003C\u002Fcode\u003E и \u003Ccode\u003E__ne__\u003C\u002Fcode\u003E, так как это приведёт к странному поведению (например, \u003Ccode\u003EWord('foo') == Word('bar')\u003C\u002Fcode\u003E будет расцениваться как истина). В этом нет смысла при тестировании на эквивалентность, основанную на длине, поэтому мы оставляем стандартную проверку на эквивалентность от \u003Ccode\u003Estr\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\nСейчас, кажется, удачное время упомянуть, что вы не должны определять каждый из магических методов сравнения, чтобы полностью охватить все сравнения. Стандартная библиотека любезно предоставляет нам класс-декторатор в модуле \u003Ccode\u003Efunctools\u003C\u002Fcode\u003E, который и определит все сравнивающие методы, от вас достаточно определить только \u003Ccode\u003E__eq__\u003C\u002Fcode\u003E и ещё один (\u003Ccode\u003E__gt__\u003C\u002Fcode\u003E, \u003Ccode\u003E__lt__\u003C\u002Fcode\u003E и т.п.) Эта возможность доступна начиная с 2.7 версии Питона, но если это вас устраивает, вы сэкономите кучу времени и усилий. Для того, чтобы задействовать её, поместите \u003Ccode\u003E@total_ordering\u003C\u002Fcode\u003E над вашим определением класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E\u003Ca name=\"numeric\"\u003E\u003C\u002Fa\u003EЧисловые магические методы\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТочно так же, как вы можете определить, каким образом ваши объекты будут сравниваться операторами сравнения, вы можете определить их поведение для числовых операторов. Приготовтесь, друзья, их много. Для лучшей организации, я разбил числовые магические методы на 5 категорий: унарные операторы, обычные арифметические операторы, отражённые арифметические операторы (подробности позже), составные присваивания и преобразования типов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EУнарные операторы и функции\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nУнарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__pos__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для унарного плюса (\u003Ccode\u003E+some_object\u003C\u002Fcode\u003E)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__neg__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для отрицания(\u003Ccode\u003E-some_object\u003C\u002Fcode\u003E)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__abs__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для встроенной функции \u003Ccode\u003Eabs()\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__invert__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для инвертирования оператором \u003Ccode\u003E~\u003C\u002Fcode\u003E. Для объяснения что он делает смотри \u003Ca href=\"http:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBitwise_operation#NOT\"\u003Eстатью в Википедии о бинарных операторах\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__round__(self, n)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для встроенной функции \u003Ccode\u003Eround()\u003C\u002Fcode\u003E. \u003Ccode\u003En\u003C\u002Fcode\u003E это число знаков после запятой, до которого округлить.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__floor__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для \u003Ccode\u003Emath.floor()\u003C\u002Fcode\u003E, то есть, округления до ближайшего меньшего целого.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ceil__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для \u003Ccode\u003Emath.ceil()\u003C\u002Fcode\u003E, то есть, округления до ближайшего большего целого.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__trunc__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для \u003Ccode\u003Emath.trunc()\u003C\u002Fcode\u003E, то есть, обрезания до целого.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EОбычные арифметические операторы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nТеперь рассмотрим обычные бинарные операторы (и ещё пару функций): +, -, * и похожие. Они, по большей части, отлично сами себя описывают.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__add__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nСложение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__sub__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВычитание.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__mul__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nУмножение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__floordiv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЦелочисленное деление, оператор \u003Ccode\u003E\u002F\u002F\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__div__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДеление, оператор \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__truediv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003EПравильное\u003C\u002Fem\u003E деление. Заметьте, что это работает только когда используется \u003Ccode\u003Efrom __future__ import division\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__mod__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОстаток от деления, оператор \u003Ccode\u003E%\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__divmod__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для встроенной функции \u003Ccode\u003Edivmod()\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__pow__\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВозведение в степень, оператор \u003Ccode\u003E**\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__lshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный сдвиг влево, оператор \u003Ccode\u003E&lt;&lt;\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный сдвиг вправо, оператор \u003Ccode\u003E\u003E\u003E\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__and__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичное И, оператор \u003Ccode\u003E&amp;\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__or__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичное ИЛИ, оператор \u003Ccode\u003E|\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__xor__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный xor, оператор \u003Ccode\u003E^\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EОтражённые арифметические операторы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПомните как я сказал, что собираюсь остановиться на отражённой арифметике подробнее? Вы могли подумать, что это какая-то большая, страшная и непонятная концепция. На самом деле всё очень просто. Вот пример:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Esome_object + other\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто «обычное» сложение. Единственное, чем отличается эквивалентное отражённое выражение, это порядок слагаемых:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eother + some_object\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТаким образом, все эти магические методы делают то же самое, что и их обычные версии, за исключением выполнения операции с \u003Ccode\u003Eother\u003C\u002Fcode\u003E в качестве первого операнда и \u003Ccode\u003Eself\u003C\u002Fcode\u003E в качестве второго. В большинстве случаев, результат отражённой операции такой же, как её обычный эквивалент, поэтому при определении \u003Ccode\u003E__radd__\u003C\u002Fcode\u003E вы можете ограничиться вызовом \u003Ccode\u003E__add__\u003C\u002Fcode\u003E да и всё. Заметьте, что объект слева от оператора (\u003Ccode\u003Eother\u003C\u002Fcode\u003E в примере) не должен иметь обычной неотражённой версии этого метода. В нашем примере, \u003Ccode\u003Esome_object.__radd__\u003C\u002Fcode\u003E будет вызван только если в \u003Ccode\u003Eother\u003C\u002Fcode\u003E не определён \u003Ccode\u003E__add__\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__radd__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое сложение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rsub__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое вычитание.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rmul__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое умножение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rfloordiv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое целочисленное деление, оператор \u003Ccode\u003E\u002F\u002F\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rdiv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое деление, оператор \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rtruediv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое \u003Cem\u003Eправильное\u003C\u002Fem\u003E деление. Заметьте, что работает только когда используется \u003Ccode\u003Efrom __future__ import division\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rmod__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённый остаток от деления, оператор \u003Ccode\u003E%\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rdivmod__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для встроенной функции \u003Ccode\u003Edivmod()\u003C\u002Fcode\u003E, когда вызывается \u003Ccode\u003Edivmod(other, self)\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rpow__\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое возведение в степерь, оператор \u003Ccode\u003E**\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rlshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённый двоичный сдвиг влево, оператор \u003Ccode\u003E&lt;&lt;\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rrshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённый двоичный сдвиг вправо, оператор \u003Ccode\u003E\u003E\u003E\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rand__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое двоичное И, оператор \u003Ccode\u003E&amp;\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ror__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённое двоичное ИЛИ, оператор \u003Ccode\u003E|\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__rxor__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОтражённый двоичный xor, оператор \u003Ccode\u003E^\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Ch4\u003EСоставное присваивание\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ Питоне широко представлены и магические методы для составного присваивания. Вы скорее всего уже знакомы с составным присваиванием, это комбинация «обычного» оператора и присваивания. Если всё ещё непонятно, вот пример:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ex = 5\nx += 1 # другими словами x = x + 1\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКаждый из этих методов должен возвращать значение, которое будет присвоено переменной слева (например, для \u003Ccode\u003Ea += b\u003C\u002Fcode\u003E, \u003Ccode\u003E__iadd__\u003C\u002Fcode\u003E должен вернуть \u003Ccode\u003Ea + b\u003C\u002Fcode\u003E, что будет присвоено \u003Ccode\u003Ea\u003C\u002Fcode\u003E). Вот список:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__iadd__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nСложение с присваиванием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__isub__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВычитание с присваиванием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__imul__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nУмножение с присваиванием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ifloordiv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЦелочисленное деление с присваиванием, оператор \u003Ccode\u003E\u002F\u002F=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__idiv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДеление с присваиванием, оператор \u003Ccode\u003E\u002F=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__itruediv__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003EПравильное\u003C\u002Fem\u003E деление с присваиванием. Заметьте, что работает только если используется \u003Ccode\u003Efrom __future__ import division\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__imod_(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОстаток от деления с присваиванием, оператор \u003Ccode\u003E%=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ipow__\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВозведение в степерь с присваиванием, оператор \u003Ccode\u003E**=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ilshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный сдвиг влево с присваиванием, оператор \u003Ccode\u003E&lt;&lt;=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__irshift__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный сдвиг вправо с присваиванием, оператор \u003Ccode\u003E\u003E\u003E=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__iand__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичное И с присваиванием, оператор \u003Ccode\u003E&amp;=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ior__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичное ИЛИ с присваиванием, оператор \u003Ccode\u003E|=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__ixor__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДвоичный xor с присваиванием, оператор \u003Ccode\u003E^=\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Ch4\u003EМагические методы преобразования типов\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nКроме того, в Питоне множество магических методов, предназначенных для определния поведения для встроенных функций преобразования типов, таких как \u003Ccode\u003Efloat()\u003C\u002Fcode\u003E. Вот они все:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__int__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в int.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__long__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в long.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__float__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в float.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__complex__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в комплексное число.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__oct__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в восьмеричное число.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__hex__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа в шестнадцатиричное число.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__index__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПреобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]). Если вы определяете свой числовый тип, который может использоваться как индекс списка, вы должны определить \u003Ccode\u003E__index__\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__trunc__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВызывается при \u003Ccode\u003Emath.trunc(self)\u003C\u002Fcode\u003E. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__coerce__(self, other)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nМетод для реализации арифметики с операндами разных типов. \u003Ccode\u003E__coerce__\u003C\u002Fcode\u003E должен вернуть \u003Ccode\u003ENone\u003C\u002Fcode\u003E если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из \u003Ccode\u003Eself\u003C\u002Fcode\u003E и \u003Ccode\u003Eother\u003C\u002Fcode\u003E, преобразованные к одному типу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"representations\"\u003E\u003C\u002Fa\u003EПредставление своих классов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЧасто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__str__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Estr()\u003C\u002Fcode\u003E, вызванной для экземпляра вашего класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__repr__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Erepr()\u003C\u002Fcode\u003E, вызыванной для экземпляра вашего класса. Главное отличие от \u003Ccode\u003Estr()\u003C\u002Fcode\u003E в целевой аудитории. \u003Ccode\u003Erepr()\u003C\u002Fcode\u003E больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне), а \u003Ccode\u003Estr()\u003C\u002Fcode\u003E предназначен для чтения людьми.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__unicode__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Eunicode()\u003C\u002Fcode\u003E, вызыванной для экземпляра вашего класса. \u003Ccode\u003Eunicode()\u003C\u002Fcode\u003E похож на \u003Ccode\u003Estr()\u003C\u002Fcode\u003E, но возвращает строку в юникоде. Будте осторожны: если клиент вызывает \u003Ccode\u003Estr()\u003C\u002Fcode\u003E на экземпляре вашего класса, а вы определили только \u003Ccode\u003E__unicode__()\u003C\u002Fcode\u003E, то это не будет работать. Постарайтесь всегда определять \u003Ccode\u003E__str__()\u003C\u002Fcode\u003E для случая, когда кто-то не имеет такой роскоши как юникод.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__format__(self, formatstr)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, \u003Ccode\u003E\"Hello, {0:abc}!\".format(a)\u003C\u002Fcode\u003E приведёт к вызову \u003Ccode\u003Ea.__format__(\"abc\")\u003C\u002Fcode\u003E. Это может быть полезно для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__hash__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Ehash()\u003C\u002Fcode\u003E, вызыванной для экземпляра вашего класса. Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно нужно определять и \u003Ccode\u003E__eq__\u003C\u002Fcode\u003E тоже. Руководствуйтесь следующим правилом: \u003Ccode\u003Ea == b\u003C\u002Fcode\u003E подразумевает \u003Ccode\u003Ehash(a) == hash(b)\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__nonzero__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Ebool()\u003C\u002Fcode\u003E, вызванной для экземпляра вашего класса. Должна вернуть True или False, в зависимости от того, когда вы считаете экземпляр соответствующим True или False.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__dir__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Edir()\u003C\u002Fcode\u003E, вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю список атрибутов. Обычно, определение \u003Ccode\u003E__dir__\u003C\u002Fcode\u003E не требуется, но может быть жизненно важно для интерактивного использования вашего класса, если вы переопределили \u003Ccode\u003E__getattr__\u003C\u002Fcode\u003E или \u003Ccode\u003E__getattribute__\u003C\u002Fcode\u003E (с которыми вы встретитесь в следующей части), или каким-либо другим образом динамически создаёте атрибуты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__sizeof__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение функции \u003Ccode\u003Esys.getsizeof()\u003C\u002Fcode\u003E, вызыванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах. Он главным образом полезен для классов, определённых в расширениях на C, но всё-равно полезно о нём знать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nМы почти закончили со скучной (и лишённой примеров) частью руководства по магическим методам. Теперь, когда мы рассмотрели самые базовые магические методы, пришло время перейти к более продвинутому материалу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"access\"\u003E\u003C\u002Fa\u003EКонтроль доступа к атрибутам\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nМногие люди, пришедшие в Питон из других языков, жалуются на отсутствие настоящей инкапсуляции для классов (например, нет способа определить приватные атрибуты с публичными методами доступа). Это не совсем правда: просто многие вещи, связанные с инкапсуляцией, Питон реализует через «магию», а не явными модификаторами для методов и полей. Смотрите:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getattr__(self, name)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВы можете определить поведение для случая, когда пользователь пытается обратиться к атрибуту, который не существует (совсем или пока ещё). Это может быть полезным для перехвата и перенаправления частых опечаток, предупреждения об использовании устаревших атрибутов (вы можете всё-равно вычислить и вернуть этот атрибут, если хотите), или хитро возвращать \u003Ccode\u003EAttributeError\u003C\u002Fcode\u003E, когда это вам нужно. Правда, этот метод вызывается только когда пытаются получить доступ к несуществующему атрибуту, поэтому это не очень хорошее решение для инкапсуляции.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__setattr__(self, name, value)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВ отличии от \u003Ccode\u003E__getattr__\u003C\u002Fcode\u003E, \u003Ccode\u003E__setattr__\u003C\u002Fcode\u003E решение для инкапсуляции. Этот метод позволяет вам определить поведение для присвоения значения атрибуту, независимо от того существует атрибут или нет. То есть, вы можете определить любые правила для любых изменений значения атрибутов. Впрочем, вы должны быть осторожны с тем, как использовать \u003Ccode\u003E__setattr__\u003C\u002Fcode\u003E, смотрите пример нехорошего случая в конце этого списка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__delattr__\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЭто то же, что и \u003Ccode\u003E__setattr__\u003C\u002Fcode\u003E, но для удаления атрибутов, вместо установки значений. Здесь требуются те же меры предосторожности, что и в \u003Ccode\u003E__setattr__\u003C\u002Fcode\u003E чтобы избежать бесконечной рекурсии (вызов \u003Ccode\u003Edel self.name\u003C\u002Fcode\u003E в определении \u003Ccode\u003E__delattr__\u003C\u002Fcode\u003E вызовет бесконечную рекурсию).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getattribute__(self, name)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E__getattribute__\u003C\u002Fcode\u003E выглядит к месту среди своих коллег \u003Ccode\u003E__setattr__\u003C\u002Fcode\u003E и \u003Ccode\u003E__delattr__\u003C\u002Fcode\u003E, но я бы не рекомендовал вам его использовать. \u003Ccode\u003E__getattribute__\u003C\u002Fcode\u003E может использоваться только с классами нового типа (в новых версиях Питона все классы нового типа, а в старых версиях вы можете получить такой класс унаследовавшись от \u003Ccode\u003Eobject\u003C\u002Fcode\u003E). Этот метод позволяет вам определить поведение для \u003Cem\u003Eкаждого\u003C\u002Fem\u003E случая доступа к атрибутам (а не только к несуществующим, как \u003Ccode\u003E__getattr__(self, name)\u003C\u002Fcode\u003E). Он страдает от таких же проблем с бесконечной рекурсией, как и его коллеги (на этот раз вы можете вызывать \u003Ccode\u003E__getattribute__\u003C\u002Fcode\u003E у базового класса, чтобы их предотвратить). Он, так же, главным образом устраняет необходимость в \u003Ccode\u003E__getattr__\u003C\u002Fcode\u003E, который в случае реализации \u003Ccode\u003E__getattribute__\u003C\u002Fcode\u003E может быть вызван только явным образом или в случае генерации исключения \u003Ccode\u003EAttributeError\u003C\u002Fcode\u003E. Вы конечно можете использовать этот метод (в конце концов, это ваш выбор), но я бы не рекомендовал, потому что случаев, когда он действительно полезен очень мало (намного реже нужно переопределять поведение при получении, а не при установке значения) и реализовать его без возможных ошибок очень сложно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nВы можете запросто получить проблему при определении любого метогда, управляющего доступом к атрибутам. Рассмотрим пример:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef __setattr__(self, name, value):\n    self.name = value\n    # это рекурсия, так как всякий раз, когда любому атрибуту присваивается значение,\n    # вызывается  __setattr__().\n    # тоесть, на самом деле это равнозначно self.__setattr__('name', value). \n    # Так как метод вызывает сам себя, рекурсия продолжится бесконечно, пока всё не упадёт\n\ndef __setattr__(self, name, value):\n    self.__dict__[name] = value # присваивание в словарь переменных класса\n    # дальше определение произвольного поведения\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕщё раз, мощь магических методов в Питоне невероятна, а с большой силой приходит и большая ответственность. Важно знать, как правильно использовать магические методы, ничего не ломая.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, что мы узнали об управлении доступом к атрибутам? Их не нужно использовать легкомысленно. На самом деле, они имеют склонность к чрезмерной мощи и нелогичности. Причина, по которой они всё-таки существуют, в удволетворении определённого желания: Питон склонен не запрещать плохие штуки полностью, а только усложнять их использование. Свобода первостепенна, поэтому вы на самом деле можете делать всё, что хотите. Вот пример использования методов контроля доступа (заметьте, что мы используем \u003Ccode\u003Esuper\u003C\u002Fcode\u003E, так как не все классы имеют атрибут \u003Ccode\u003E__dict__\u003C\u002Fcode\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass AccessCounter(object):\n    '''Класс, содержащий атрибут value и реализующий счётчик доступа к нему.\n    Счётчик увеличивается каждый раз, когда меняется value.'''\n\n    def __init__(self, val):\n        super(AccessCounter, self).__setattr__('counter', 0)\n        super(AccessCounter, self).__setattr__('value', val)\n\n    def __setattr__(self, name, value):\n        if name == 'value':\n            super(AccessCounter, self).__setattr__('counter', self.counter + 1)\n        # Не будем делать здесь никаких условий.\n        # Если вы хотите предотвратить изменение других атрибутов,\n        # выбросьте исключение AttributeError(name)\n        super(AccessCounter, self).__setattr__(name, value)\n\n    def __delattr__(self, name):\n        if name == 'value':\n            super(AccessCounter, self).__setattr__('counter', self.counter + 1)\n        super(AccessCounter, self).__delattr__(name)]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"sequence\"\u003E\u003C\u002Fa\u003EСоздание произвольных последовательностей\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ Питоне существует множество способов заставить ваши классы вести себя как встроенные последовательности (словари, кортежи, списки, строки и так далее). Это, безусловно, мои любимые магические методы, из-за до абсурда высокой степени контроля, которую они дают и той магии, от которой с экземплярами ваших классов вдруг начинает прекрасно работать целое множество глобальных функций. Но, до того как мы перейдём ко всяким хорошим вещам, мы должны знать о протоколах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EПротоколы\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nТеперь, когда речь зашла о создании собственных последовательностей в Питоне, пришло время поговорить о \u003Cem\u003Eпротоколах\u003C\u002Fem\u003E. Протоколы немного похожи на интерфейсы в других языках тем, что они предоставляют набор методов, которые вы должны реализовать. Однако, в Питоне протоколы абсолютно ни к чему не обязывают и не требуют обязательно реализовать какое-либо объявление. Наверное, они больше похожи на руководящие указания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПочему мы заговорили о протоколах? Потому, что реализация произвольных контейнерных типов в Питоне влечёт за собой использование некоторых из них. Во-первых, протокол для определения неизменяемых контейнеров: чтобы создать неизменяемый контейнер, вы должны только определить \u003Ccode\u003E__len__\u003C\u002Fcode\u003E и \u003Ccode\u003E__getitem__\u003C\u002Fcode\u003E (продробнее о них дальше). Протокол изменяемого контейнера требует того же, что и неизменяемого контейнера, плюс \u003Ccode\u003E__setitem__\u003C\u002Fcode\u003E и \u003Ccode\u003E__delitem__\u003C\u002Fcode\u003E. И, наконец, если вы хотите, чтобы ваши объекты можно было перебирать итерацией, вы должны определить \u003Ccode\u003E__iter__\u003C\u002Fcode\u003E, который возвращает итератор. Этот итератор должен соответствовать протоколу итератора, который требует методов \u003Ccode\u003E__iter__\u003C\u002Fcode\u003E(возвращает самого себя) и \u003Ccode\u003Enext\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EМагия контейнеров\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nБез дальнейшего промедления, вот магические методы, используемые контейнерами:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__len__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВозвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getitem__(self, key)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение при доступе к элементу, используя синтаксис \u003Ccode\u003Eself[key]\u003C\u002Fcode\u003E. Тоже относится и к протоколу изменяемых и к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: \u003Ccode\u003ETypeError\u003C\u002Fcode\u003E если неправильный тип ключа и \u003Ccode\u003EKeyError\u003C\u002Fcode\u003E если ключу не соответствует никакого значения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__setitem__(self, key, value)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение при присваивании значения элементу, используя синтаксис \u003Ccode\u003Eself[nkey] = value\u003C\u002Fcode\u003E. Часть протокола изменяемого контейнера. Опять же, вы должны выбрасывать \u003Ccode\u003EKeyError\u003C\u002Fcode\u003E и \u003Ccode\u003ETypeError\u003C\u002Fcode\u003E в соответсвующих случаях.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__delitem__(self, key)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение при удалении элемента (то есть \u003Ccode\u003Edel self[key]\u003C\u002Fcode\u003E). Это часть только протокола для изменяемого контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__iter__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДолжен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции \u003Ccode\u003Eiter()\u003C\u002Fcode\u003E и в случае перебора элементов контейнера выражением \u003Ccode\u003Efor x in container:\u003C\u002Fcode\u003E. Итераторы сами по себе объекты и они тоже должны определять метод \u003Ccode\u003E__iter__\u003C\u002Fcode\u003E, который возвращает \u003Ccode\u003Eself\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__reversed__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВызывается чтобы определить поведения для встроенной функции \u003Ccode\u003Ereversed()\u003C\u002Fcode\u003E. Должен вернуть обратную версию последовательности. Реализуйте метод только если класс упорядоченный, как список или кортеж.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__contains__(self, item)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E__contains__\u003C\u002Fcode\u003E предназначен для проверки принадлежности элемента с помощью \u003Ccode\u003Ein\u003C\u002Fcode\u003E и \u003Ccode\u003Enot in\u003C\u002Fcode\u003E. Вы спросите, почему же это не часть протокола последовательности? Потому что когда \u003Ccode\u003E__contains__\u003C\u002Fcode\u003E не определён, Питон просто перебирает всю последовательность элемент за элементом и возвращает \u003Ccode\u003ETrue\u003C\u002Fcode\u003E если находит нужный.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__missing__(self, key)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E__missing__\u003C\u002Fcode\u003E используется при наследовании от \u003Ccode\u003Edict\u003C\u002Fcode\u003E. Определяет поведение для для каждого случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь \u003Ccode\u003Ed\u003C\u002Fcode\u003E и я пишу \u003Ccode\u003Ed[\"george\"]\u003C\u002Fcode\u003E когда \u003Ccode\u003E\"george\"\u003C\u002Fcode\u003E не является ключом в словаре, вызывается \u003Ccode\u003Ed.__missing__(\"george\")\u003C\u002Fcode\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4\u003EПример\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nДля примера, давайте посмотрим на список, который реализует некоторые функциональные конструкции, которые вы могли встретить в других языках (Хаскеле, например).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass FunctionalList:\n    '''Класс-обёртка над списком с добавлением некоторой функциональной магии: head,\n    tail, init, last, drop, take.'''\n\n    def __init__(self, values=None):\n        if values is None:\n            self.values = []\n        else:\n            self.values = values\n\n    def __len__(self):\n        return len(self.values)\n\n    def __getitem__(self, key):\n        # если значение или тип ключа некорректны, list выбросит исключение\n        return self.values[key]\n\n    def __setitem__(self, key, value):\n        self.values[key] = value\n\n    def __delitem__(self, key):\n        del self.values[key]\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __reversed__(self):\n        return FunctionalList(reversed(self.values))\n\n    def append(self, value):\n        self.values.append(value)\n    def head(self):\n        # получить первый элемент\n        return self.values[0]\n    def tail(self):\n        # получить все элементы после первого\n        return self.values[1:]\n    def init(self):\n        # получить все элементы кроме последнего\n        return self.values[:-1]\n    def last(self):\n        # получить последний элемент\n        return self.values[-1]\n    def drop(self, n):\n        # все элементы кроме первых n\n        return self.values[n:]\n    def take(self, n):\n        # первые n элементов\n        return self.values[:n]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь у вас есть полезный (относительно) пример реализации своей собственной последовательности. Существуют, конечно, и куда более практичные реализации произвольных последовательностей, но большое их число уже реализовано в стандартной библиотеке (с батарейками в комплекте, да?), такие как \u003Ccode\u003ECounter\u003C\u002Fcode\u003E, \u003Ccode\u003EOrderedDict\u003C\u002Fcode\u003E, \u003Ccode\u003ENamedTuple\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"reflection\"\u003E\u003C\u002Fa\u003EОтражение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВы можете контролировать и отражение, использующее встроенные функции \u003Ccode\u003Eisinstance()\u003C\u002Fcode\u003E и \u003Ccode\u003Eissubclass()\u003C\u002Fcode\u003E, определив некоторые магические методы. Вот они:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__instancecheck__(self, instance)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПроверяет, является ли экземлпяр членом вашего класса (\u003Ccode\u003Eisinstance(instance, class)\u003C\u002Fcode\u003E, например.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__subclasscheck__(self, subclass)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПроверяет, является наследуется ли класс от вашего класса (\u003Ccode\u003Eissubclass(subclass, class)\u003C\u002Fcode\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nМожет показаться, что вариантов полезного использования этих магических методов немного и, возможно, это на самом деле так. Я не хочу тратить слишком много времени на магические методы отражения, не особо они и важные, но они отражают кое-что важное об объектно-ориентированном программировании в Питоне и о Питоне вообще: почти всегда существует простой способ что-либо сделать, даже если надобность в этом «что-либо» возникает очень редко. Эти магические методы могут не выглядеть полезными, но если они вам когда-нибудь понадобятся, вы будете рады вспомнить, что они есть (и для этого вы читаете настоящее руководство!).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"callable\"\u003E\u003C\u002Fa\u003EВызываемые объекты\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nКак вы наверное уже знаете, в Питоне функции являются объектами первого класса. Это означает, что они могут быть переданы в функции или методы так же, как любые другие объекты. Это невероятно мощная особенность.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСпециальный магический метод позволяет экземплярам вашего класса вести себя так, как будто они функции, тоесть вы сможете «вызывать» их, передавать их в функции, которые принимают функции в качестве аргументов и так далее. Это другая удобная особенность, которая делает программирование на Питоне таким приятным.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__call__(self, [args...])\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nПозволяет любому экземпляру вашего класса быть вызванным как-будто он функция. Главным образом это означает, что \u003Ccode\u003Ex()\u003C\u002Fcode\u003E означает то же, что и \u003Ccode\u003Ex.__call__()\u003C\u002Fcode\u003E. Заметьте, \u003Ccode\u003E__call__\u003C\u002Fcode\u003E принимает произвольное число аргументов; то есть, вы можете определить \u003Ccode\u003E__call__\u003C\u002Fcode\u003E так же как любую другую функцию, принимающую столько аргументов, сколько вам нужно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E__call__\u003C\u002Fcode\u003E, в частности, может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. «Вызвать» экземпляр может быть интуитивно понятным и элегантным способом изменить состояние объекта. Примером может быть класс, представляющий положение некоторого объекта на плоскости:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Entity:\n    '''Класс, описывающий объект на плоскости. \"Вызываемый\", чтобы обновить позицию объекта.'''\n\n    def __init__(self, size, x, y):\n        self.x, self.y = x, y\n        self.size = size\n\n    def __call__(self, x, y):\n        '''Изменить положение объекта.'''\n        self.x, self.y = x, y\n\n    # чик...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"context\"\u003E\u003C\u002Fa\u003EМенеджеры контекста\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ Питоне 2.5 было представлено новое ключевое слово вместе с новым способом повторно использовать код, ключевое слово \u003Ccode\u003Ewith\u003C\u002Fcode\u003E. Концепция менеджеров контекста не являлась новой для Питона (она была реализована раньше как часть библиотеки), но в \u003Ca href=\"http:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-0343\u002F\"\u003EPEP 343\u003C\u002Fa\u003E достигла статуса языковой конструкции. Вы могли уже видеть выражения с \u003Ccode\u003Ewith\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ewith open('foo.txt') as bar:\n    # выполнение каких-нибудь действий с bar\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМенеджеры контекста позволяют выполнить какие-то действия для настройки или очистки, когда создание объекта обёрнуто в оператор \u003Ccode\u003Ewith\u003C\u002Fcode\u003E. Поведение менеджера контекста определяется двумя магическими методами:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__enter__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет, что должен сделать менеджер контекста в начале блока, созданного оператором \u003Ccode\u003Ewith\u003C\u002Fcode\u003E. Заметьте, что возвращаемое \u003Ccode\u003E__enter__\u003C\u002Fcode\u003E значение и есть то значение, с которым производится работа внутри \u003Ccode\u003Ewith\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__exit__(self, exception_type, exception_value, traceback)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет действия менеджера контекста после того, как блок будет выполнен (или прерван во время работы). Может использоваться для контроллирования исключений, чистки, любых действий которые должны быть выполнены незамедлительно после блока внутри with. Если блок выполнен успешно, \u003Ccode\u003Eexception_type\u003C\u002Fcode\u003E, \u003Ccode\u003Eexception_value\u003C\u002Fcode\u003E, и \u003Ccode\u003Etraceback\u003C\u002Fcode\u003E будут установлены в \u003Ccode\u003ENone\u003C\u002Fcode\u003E. В другом случае вы сами выбираете, перехватывать ли исключение или предоставить это пользователю; если вы решили перехватить исключение, убедитесь, что \u003Ccode\u003E__exit__\u003C\u002Fcode\u003E возвращает \u003Ccode\u003ETrue\u003C\u002Fcode\u003E после того как всё сказано и сделано. Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E__enter__\u003C\u002Fcode\u003E и \u003Ccode\u003E__exit__\u003C\u002Fcode\u003E могут быть полезны для специфичных классов с хорошо описанным и распространённым поведением для их настройки и очистки ресурсов. Вы можете использовать эти методы и для создания общих менеджеров контекста для разных объектов. Вот пример:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Closer:\n    '''Менеджер контекста для автоматического закрытия объекта вызовом метода close \n    в with-выражении.'''\n\n    def __init__(self, obj):\n        self.obj = obj\n\n    def __enter__(self):\n        return self.obj # привязка к активному объекту with-блока\n\n    def __exit__(self, exception_type, exception_val, trace):\n        try:\n           self.obj.close()\n        except AttributeError: # у объекта нет метода close\n           print 'Not closable.'\n           return True # исключение перехвачено\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПример использования \u003Ccode\u003ECloser\u003C\u002Fcode\u003E с FTP-соединением (сокет, имеющий метод close):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E\u003E\u003E\u003E from magicmethods import Closer\n\u003E\u003E\u003E from ftplib import FTP\n\u003E\u003E\u003E with Closer(FTP('ftp.somesite.com')) as conn:\n...     conn.dir()\n...\n# output omitted for brevity\n\u003E\u003E\u003E conn.dir()\n# long AttributeError message, can't use a connection that's closed\n\u003E\u003E\u003E with Closer(int(5)) as i:\n...     i += 1\n...\nNot closable.\n\u003E\u003E\u003E i\n6\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВидите, как наша обёртка изящно управляется и с правильными и с неподходящими объектами. В этом сила менеджеров контекста и магических методов. Заметьте, что стандартная библиотека Питона включает модуль \u003Ca href=\"http:\u002F\u002Fdocs.python.org\u002Flibrary\u002Fcontextlib.html\"\u003Econtextlib\u003C\u002Fa\u003E, который включает в себя \u003Ccode\u003Econtextlib.closing()\u003C\u002Fcode\u003E — менеджер контекста, который делает приблизительно то же (без какой-либо обработки случая, когда объект не имеет метода \u003Ccode\u003Eclose()\u003C\u002Fcode\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"abcs\"\u003E\u003C\u002Fa\u003EАбстрактные базовые классы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nСмотри \u003Ca href=\"http:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002Fabc.html\"\u003Ehttp:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002Fabc.html\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"descriptor\"\u003E\u003C\u002Fa\u003EПостроение дескрипторов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДескрипторы это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из \u003Ccode\u003E__get__\u003C\u002Fcode\u003E, \u003Ccode\u003E__set__\u003C\u002Fcode\u003E или \u003Ccode\u003E__delete__\u003C\u002Fcode\u003E. Давайте рассмотрим эти магические методы:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__get__(self, instance, instance_class)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение при возвращении значения из дескриптора. \u003Ccode\u003Einstance\u003C\u002Fcode\u003E это объект, для чьего атрибута-дескриптора вызывается метод. \u003Ccode\u003Eowner\u003C\u002Fcode\u003E это тип (класс) объекта.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__set__(self, instance, value)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение при изменении значения из дескриптора. \u003Ccode\u003Einstance\u003C\u002Fcode\u003E это объект, для чьего атрибута-дескриптора вызывается метод. \u003Ccode\u003Evalue\u003C\u002Fcode\u003E это значение для установки в дескриптор.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__delete__(self, instance)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение для удаления значения из дескриптора. \u003Ccode\u003Einstance\u003C\u002Fcode\u003E это объект, владеющий дескриптором.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nТеперь пример полезного использования дескрипторов: преобразование единиц измерения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Meter(object):\n    '''Дескриптор для метра.'''\n\n    def __init__(self, value=0.0):\n        self.value = float(value)\n    def __get__(self, instance, owner):\n        return self.value\n    def __set__(self, instance, value):\n        self.value = float(value)\n\nclass Foot(object):\n    '''Дескриптор для фута.'''\n\n    def __get__(self, instance, owner):\n        return instance.meter * 3.2808\n    def __set__(self, instance, value):\n        instance.meter = float(value) \u002F 3.2808\n\nclass Distance(object):\n    '''Класс, описывающий расстояние, содержит два дескриптора для футов и\n    метров.'''\n    meter = Meter()\n    foot = Foot()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"copying\"\u003E\u003C\u002Fa\u003EКопирование\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ Питоне оператор присваивания не копирует объекты, а только добавляет ещё одну ссылку. Но для коллекций, содержащих изменяемые элементы, иногда необходимо полноценное копирование, чтобы можно было менять элементы одной последовательности, не затрагивая другую. Здесь в игру и вступает \u003Ca href=\"http:\u002F\u002Fdocs.python.org\u002Flibrary\u002Fcopy.html\"\u003E\u003Ccode\u003Ecopy\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. К счастью, модули в Питоне не обладают разумом, поэтому мы можем не беспокоиться что они вдруг начнут бесконтрольно копировать сами себя и вскоре линуксовые роботы заполонят всю планету, но мы должны сказать Питону как правильно копировать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__copy__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение \u003Ccode\u003Ecopy.copy()\u003C\u002Fcode\u003E для экземпляра вашего класса. \u003Ccode\u003Ecopy.copy()\u003C\u002Fcode\u003E возвращает \u003Cem\u003Eповерхностную копию\u003C\u002Fem\u003E вашего объекта — это означает, что хоть сам объект и создан заново, все его данные ссылаются на данные оригинального объекта. И при изменении данных нового объекта, изменения будут происходить и в оригинальном.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__deepcopy__(self, memodict={})\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОпределяет поведение \u003Ccode\u003Ecopy.deepcopy()\u003C\u002Fcode\u003E для экземпляров вашего класса. \u003Ccode\u003Ecopy.deepcopy()\u003C\u002Fcode\u003E возвращает \u003Cem\u003Eглубокую копию\u003C\u002Fem\u003E вашего объекта — копируются и объект \u003Cem\u003Eи\u003C\u002Fem\u003E его данные. \u003Ccode\u003Ememodict\u003C\u002Fcode\u003E это кэш предыдущих скопированных объектов, он предназначен для оптимизации копирования и предотвращения бесконечной рекурсии, когда копируются рекурсивные структуры данных. Когда вы хотите полностью скопировать какой-нибудь конкретный атрибут, вызовите на нём \u003Ccode\u003Ecopy.deepcopy()\u003C\u002Fcode\u003E с первым параметром \u003Ccode\u003Ememodict\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nКогда использовать эти магические методы? Как обычно — в любом случае, когда вам необходимо больше, чем стандартное поведение. Например, если вы пытаетесь скопировать объект, который содержит кэш как словарь (возможно, очень большой словарь), то может быть вам и не нужно копировать весь кэш, а обойтись всего одним в общей памяти объектов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"pickling\"\u003E\u003C\u002Fa\u003EИспользование модуля pickle на своих объектах\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nPickle это модуль для сериализации структур данных Питона и он может быть невероятно полезен, когда вам нужно сохранить состояние какого-либо объекта и восстановить его позже (обычно, в целях кэширования). Кроме того, это ещё и отличный источник переживаний и путаницы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСериализация настолько важна, что кроме своего модуля (\u003Ccode\u003Epickle\u003C\u002Fcode\u003E) имеет и свой собственный \u003Cem\u003Eпротокол\u003C\u002Fem\u003E и свои магические методы. Но для начала о том, как сериализовать с помощью pickle уже существующие типы данных (спокойно пропускайте, если вы уже знаете).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВкратце про сериализацию\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДавайте погрузимся в сериализацию. Допустим, у вас есть словарь, который вы хотите сохранить и восстановить позже. Вы должны записать его содержимое в файл, тщательно убедившись, что пишете с правильным синтаксисом, потом восстановить его, или выполнив \u003Ccode\u003Eexec()\u003C\u002Fcode\u003E, или прочитав файл. Но это в лучшем случае рискованно: если вы храните важные данные в тексте, он может быть повреждён или изменён множеством способов, с целью обрушить вашу программу или, вообще, запустить какой-нибудь опасный код на вашем компьютере. Лучше использовать pickle:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport pickle\n\ndata = {'foo': [1, 2, 3],\n        'bar': ('Hello', 'world!'),\n        'baz': True}\njar = open('data.pkl', 'wb')\npickle.dump(data, jar) # записать сериализованные данные в jar\njar.close()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИ вот, спустя несколько часов, нам снова нужен наш словарь:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport pickle\n\npkl_file = open('data.pkl', 'rb') # открываем\ndata = pickle.load(pkl_file) # сохраняем в переменную\nprint data\npkl_file.close()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧто произошло? Точно то, что и ожидалось. \u003Ccode\u003Edata\u003C\u002Fcode\u003E как-будто всегда тут и была.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь, немного об осторожности: pickle не идеален. Его файлы легко испортить случайно или преднамеренно. Pickle, может быть, безопаснее чем текстовые файлы, но он всё ещё может использоваться для запуска вредоносного кода. Кроме того, он несовместим между разными версиями Питона, поэтому если вы будете распространять свои объекты с помощью pickle, не ожидайте что все люди смогут их использовать. Тем не менее, модуль может быть мощным инструментом для кэширования и других распространённых задач с сериализацией.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСериализация собственных объектов.\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМодуль pickle не только для встроенных типов. Он может использоваться с каждым классом, реализующим его протокол. Этот протокол содержит четыре необязательных метода, позволяющих настроить то, как pickle будет с ними обращаться (есть некоторые различия для расширений на C, но это за рамками нашего руководства):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getinitargs__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЕсли вы хотите, чтобы после десериализации вашего класса был вызыван \u003Ccode\u003E__init__\u003C\u002Fcode\u003E, вы можете определить \u003Ccode\u003E__getinitargs__\u003C\u002Fcode\u003E, который должен вернуть кортеж аргументов, который будет отправлен в \u003Ccode\u003E__init__\u003C\u002Fcode\u003E. Заметьте, что этот метод работает только с классами старого стиля.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getnewargs__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nДля классов нового стиля вы можете определить, какие параметры будут переданы в \u003Ccode\u003E__new__\u003C\u002Fcode\u003E во время десериализации. Этот метод так же должен вернуть кортеж аргументов, которые будут отправлены в \u003Ccode\u003E__new__\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__getstate__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nВместо стандартного атрибута \u003Ccode\u003E__dict__\u003C\u002Fcode\u003E, где хранятся атрибуты класса, вы можете вернуть произвольные данные для сериализации. Эти данные будут переданы в \u003Ccode\u003E__setstate__\u003C\u002Fcode\u003E во время десериализации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__setstate__(self, state)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЕсли во время десериализации определён \u003Ccode\u003E__setstate__\u003C\u002Fcode\u003E, то данные объекта будут переданы сюда, вместо того чтобы просто записать всё в \u003Ccode\u003E__dict__\u003C\u002Fcode\u003E. Это парный метод для \u003Ccode\u003E__getstate__\u003C\u002Fcode\u003E: когда оба определены, вы можете представлять состояние вашего объекта так, как вы только захотите.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__reduce__(self)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЕсли вы определили свой тип (с помощью Python's C API), вы должны сообщить Питону как его сериализовать, если вы хотите, чтобы он его сериализовал. \u003Ccode\u003E__reduce__()\u003C\u002Fcode\u003E вызывается когда сериализуется объект, в котором этот метод был определён. Он должен вернуть или строку, содержащую имя глобальной переменной, содержимое которой сериализуется как обычно, или кортеж. Кортеж может содержать от 2 до 5 элементов: вызываемый объект, который будет вызван, чтобы создать десериализованный объект, кортеж аргументов для этого вызываемого объекта, данные, которые будут переданы в \u003Ccode\u003E__setstate__\u003C\u002Fcode\u003E (опционально), итератор списка элементов для сериализации (опционально) и итератор словаря элементов для сериализации (опционально).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__reduce_ex__(self, protocol)\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nИногда полезно знать версию протокола, реализуя \u003Ccode\u003E__reduce__\u003C\u002Fcode\u003E. И этого можно добиться, реализовав вместо него \u003Ccode\u003E__reduce_ex__\u003C\u002Fcode\u003E. Если \u003Ccode\u003E__reduce_ex__\u003C\u002Fcode\u003E реализован, то предпочтение при вызове отдаётся ему (вы всё-равно должны реализовать \u003Ccode\u003E__reduce__\u003C\u002Fcode\u003E для обратной совместимости).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПример\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДля примера опишем грифельную доску (\u003Ccode\u003ESlate\u003C\u002Fcode\u003E), которая запоминает что и когда было на ней записано. Впрочем, конкретно эта доска становится чистой каждый раз, когда она сериализуется: текущее значение не сохраняется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport time\n\nclass Slate:\n    '''Класс, хранящий строку и лог изменений. И забывающий своё значение после \n    сериализации.'''\n\n    def __init__(self, value):\n        self.value = value\n        self.last_change = time.asctime()\n        self.history = {}\n\n    def change(self, new_value):\n        # Изменить значение. Зафиксировать последнее значение в истории. \n        self.history[self.last_change] = self.value\n        self.value = new_value\n        self.last_change = time.asctime()\n\n    def print_changes(self):\n        print 'Changelog for Slate object:'\n        for k, v in self.history.items():\n            print '%s\\t %s' % (k, v)\n\n    def __getstate__(self):\n        # Намеренно не возвращаем self.value or self.last_change.\n        # Мы хотим \"чистую доску\" после десериализации.\n        return self.history\n\n    def __setstate__(self, state):\n        self.history = state\n        self.value, self.last_change = None, None\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"conclusion\"\u003E\u003C\u002Fa\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЦель этого руководства донести что-нибудь до каждого, кто его читает, независимо от его опыта в Питоне или объектно-ориентированном программировании. Если вы новичок в Питоне, вы получили ценные знания об основах написания функциональных, элегантных и простых для использования классов. Если вы программист среднего уровня, то вы, возможно, нашли несколько новых приятных идей и стратегий, несколько хороших способов уменьшить количество кода, написанного вами и вашими клиентами. Если же вы Питонист-эксперт, то вы обновили некоторые свои, возможно, подзабытые знания, а может и нашли парочку новых трюков. Независимо от вашего уровня, я надеюсь, что это путешествие через специальные питоновские методы было поистине магическим (не смог удержаться).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"appendix1\"\u003E\u003C\u002Fa\u003EДополнение 1: Как вызывать магические методы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nНекоторые из магических методов напрямую связаны со встроенными функциями; в этом случае совершенно очевидно как их вызывать. Однако, так бывает не всегда. Это дополнение посвящено тому, чтобы раскрыть неочевидный синтаксис, приводящий к вызову магических методов.\u003Cbr\u002F\u003E\r\n\u003Ctable\u003E\r\n\u003Cthead\u003E\r\n\u003Ctr\u003E\r\n\u003Cth\u003EМагический метод\u003C\u002Fth\u003E\r\n\u003Cth\u003EКогда он вызывается (пример)\u003C\u002Fth\u003E\r\n\u003Cth\u003EОбъяснение\u003C\u002Fth\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003C\u002Fthead\u003E\r\n\u003Ctbody\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__new__(cls [,...])\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Einstance = MyClass(arg1, arg2)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__new__\u003C\u002Fcode\u003E вызывается при создании экземпляра\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__init__(self [,...])\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Einstance = MyClass(arg1, arg2)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__init__\u003C\u002Fcode\u003E вызывается при создании экземпляра\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__cmp__(self, other)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself == other\u003C\u002Fcode\u003E, \u003Ccode\u003Eself \u003E other\u003C\u002Fcode\u003E, etc.\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EВызывается для любого сравнения\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__pos__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E+self\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EУнарный знак плюса\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__neg__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E-self\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EУнарный знак минуса\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__invert__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E~self\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПобитовая инверсия\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__index__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ex[self]\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПреобразование, когда объект используется как индекс\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__nonzero__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ebool(self)\u003C\u002Fcode\u003E, \u003Ccode\u003Eif self:\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EБулевое значение объекта\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__getattr__(self, name)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself.name # name не определено\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПытаются получить несуществующий атрибут\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__setattr__(self, name, val)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself.name = val\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПрисвоение любому атрибуту\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__delattr__(self, name)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Edel self.name\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EУдаление атрибута\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__getattribute__(self, name)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself.name\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПолучить любой атрибут\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__getitem__(self, key)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself[key]\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПолучение элемента через индекс\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__setitem__(self, key, val)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself[key] = val\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПрисвоение элементу через индекс\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__delitem__(self, key)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Edel self[key]\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EУдаление элемента через индекс\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__iter__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Efor x in self\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EИтерация\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__contains__(self, value)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Evalue in self\u003C\u002Fcode\u003E, \u003Ccode\u003Evalue not in self\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EПроверка принадлежности с помощью \u003Ccode\u003Ein\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__call__(self [,...])\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Eself(args)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E«Вызов» экземпляра\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__enter__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ewith self as x:\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ewith\u003C\u002Fcode\u003E оператор менеджеров контекста\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__exit__(self, exc, val, trace)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ewith self as x:\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Ewith\u003C\u002Fcode\u003E оператор менеджеров контекста\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__getstate__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Epickle.dump(pkl_file, self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EСериализация\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003Ctr\u003E\r\n\u003Ctd\u003E\u003Ccode\u003E__setstate__(self)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003E\u003Ccode\u003Edata = pickle.load(pkl_file)\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\r\n\u003Ctd\u003EСериализация\u003C\u002Ftd\u003E\r\n\u003C\u002Ftr\u003E\r\n\u003C\u002Ftbody\u003E\r\n\u003C\u002Ftable\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНадеюсь, эта таблица избавит вас от любых вопросов о том, что за синтаксис вызова магических методов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"appendix2\"\u003E\u003C\u002Fa\u003EДополнение 2: Изменения в Питоне 3\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nОпишем несколько главных случаев, когда Питон 3 отличается от 2.x в терминах его объектной модели:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EТак как в Питоне 3 различий между строкой и юникодом больше нет, \u003Ccode\u003E__unicode__\u003C\u002Fcode\u003E исчез, а появился \u003Ccode\u003E__bytes__\u003C\u002Fcode\u003E (который ведёт себя так же как \u003Ccode\u003E__str__\u003C\u002Fcode\u003E и \u003Ccode\u003E__unicode__\u003C\u002Fcode\u003E в 2.7) для новых встроенных функций построения байтовых массивов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EТак как деление в Питоне 3 теперь по-умолчанию «правильное деление», \u003Ccode\u003E__div__\u003C\u002Fcode\u003E больше нет.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__coerce__\u003C\u002Fcode\u003E больше нет, из-за избыточности и странного поведения.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__cmp__\u003C\u002Fcode\u003E больше нет, из-за избыточности.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003E__nonzero__\u003C\u002Fcode\u003E было переименовано в \u003Ccode\u003E__bool__\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Enext\u003C\u002Fcode\u003E у итераторов был \u003Ca href=\"http:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-3114\u002F\"\u003Eпереименован\u003C\u002Fa\u003E в \u003Ccode\u003E__next__\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"python"},{"titleHtml":"magic methods"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F186608\u002Fa399eb2aab51e2620374b39af74c7fc3\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F186608\u002Fa399eb2aab51e2620374b39af74c7fc3\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F186608\\\u002F\"},\"headline\":\"Руководство по магическим методам в Питоне\",\"datePublished\":\"2013-07-15T13:00:53+04:00\",\"dateModified\":\"2013-07-17T19:20:43+04:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Сергей Головин\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Это перевод 1.17 версии руководства от Rafe Kettler.   Содержание  Вступление Конструирование и инициализация Переопределение операторов на произвольных классах...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F186608\\\u002F#post-content-body\",\"about\":[\"h_python\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F186608\\\u002Fa399eb2aab51e2620374b39af74c7fc3\\\u002F\"]}","metaDescription":"Это перевод 1.17 версии руководства от Rafe Kettler.\r\n\r\n\r\nСодержание\r\n\r\nВступление\r\nКонструирование и инициализация\r\nПереопределение операторов на произвольных классах\r\nМагические методы...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{"ARTICLES_LIST_TOP_PERIOD_DAILY":[]},"isLoading":false,"pagesCount":{"ARTICLES_LIST_TOP_PERIOD_DAILY":0},"route":{"name":"ARTICLES_LIST_TOP_PERIOD","params":{"period":"daily"},"query":{}},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"en","hl":"en"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"myFeedSettings":{"hubIds":{},"hubRefs":{}},"newsBlock":{"articleRefs":{},"articleIds":{},"requestTime":{}},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":["562690","543868","526002"],"similarListRefs":{"526002":{"id":"526002","timePublished":"2020-11-03T06:02:41+00:00","isCorporative":false,"lang":"en","titleHtml":"Making python's dream of multithreading come true","editorVersion":"1.0","postType":"article","postLabels":[],"author":{"id":"2239762","alias":"byko3y","fullname":null,"avatarUrl":null,"speciality":"Программист"},"statistics":{"commentsCount":0,"favoritesCount":3,"readingCount":3336,"score":4,"votesCount":4},"hubs":[{"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Development","titleHtml":"Development"}],"relatedData":null,"leadData":{"textHtml":"\u003Ch1 id=\"intro\"\u003EIntro\u003C\u002Fh1\u003E\u003Cbr\u003E\r\n\u003Cp\u003ESo you are writing some CPU-intensive code in Python and really trying to find ways out of its single-threaded prison. You might be looking towards Numba's &quot;nopython parallel&quot; mode, you might be using forked processes with multiprocessing, you might be writing microservices with database-like coordinators, or even writing your own multithreaded programs in C\u002FC++ just like creators of TensorFlow did.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EIn this article I'm describing a rationale for my pet project where I try to implement facilities for general purpose multitasking to be used in a form of simple python code, employing a database-like approach for interpreters communication, while keeping the GIL (Global Interpreter Lock) and trying to be as pythonic as possible.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fwb\u002Fwx\u002F4-\u002Fwbwx4-jynsxjiuviuxuu0liwcn4.png\"\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EIt could also become handy in the light of upcoming \u003Ca href=\"https:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-0554\u002F\" rel=\"nofollow\"\u003Emultiple interpreters support in CPython\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EAs far as I know, nobody came that far in trying to provide Python program with native shareable storage. The last closest attempt was \u003Ca href=\"http:\u002F\u002Fposhmodule.sourceforge.net\u002Fposh\u002Fhtml\u002Findex.html\" rel=\"nofollow\"\u003EPython Object Sharing\u003C\u002Fa\u003E which is pretty much dead by now. I hope my project won't meet the same fate.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Read more &rarr;","image":null},"status":"published","plannedPublishTime":null,"checked":null},"543868":{"id":"543868","timePublished":"2021-02-24T07:31:26+00:00","isCorporative":true,"lang":"en","titleHtml":"Free Heroes of Might and Magic II: Open-Source Project that You Want to Be Part of","editorVersion":"2.0","postType":"article","postLabels":[],"author":{"id":"1837483","alias":"Stolyarrr","fullname":"Vladislav Stolyarov","avatarUrl":null,"speciality":"Разработчик"},"statistics":{"commentsCount":0,"favoritesCount":0,"readingCount":3077,"score":6,"votesCount":6},"hubs":[{"id":"18095","alias":"pvs-studio","type":"corporative","title":"PVS-Studio corporate blog","titleHtml":"PVS-Studio corporate blog","isProfiled":false},{"id":"144","alias":"open_source","type":"collective","title":"Open source","titleHtml":"Open source","isProfiled":true},{"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true},{"id":"7773","alias":"gamedev","type":"collective","title":"Game development","titleHtml":"Game development","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Development","titleHtml":"Development"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003ERecently we found out that the new version of the fheroes2 project was released. In our company there are many fans of Heroes of Might and Magic game series. So, we couldn't pass it up and checked the project by PVS-Studio.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F57b\u002F941\u002Ff0d\u002F57b941f0d515f9089d10eb2eb1174099.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F57b\u002F941\u002Ff0d\u002F57b941f0d515f9089d10eb2eb1174099.png","fit":"cover","positionY":0,"positionX":0}},"status":"published","plannedPublishTime":null,"checked":null},"562690":{"id":"562690","timePublished":"2021-06-14T14:35:26+00:00","isCorporative":false,"lang":"en","titleHtml":"[Tutorial] How to set up Atom IDE for python development","editorVersion":"2.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"id":"2234126","alias":"RUDIEMEANT","fullname":"Rudie","avatarUrl":null,"speciality":"Python backend developer."},"statistics":{"commentsCount":1,"favoritesCount":1,"readingCount":1241,"score":3,"votesCount":3},"hubs":[{"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true},{"id":"359","alias":"programming","type":"collective","title":"Programming","titleHtml":"Programming","isProfiled":true},{"id":"7289","alias":"nix","type":"collective","title":"*nix","titleHtml":"*nix","isProfiled":true},{"id":"18790","alias":"github","type":"collective","title":"GitHub","titleHtml":"GitHub","isProfiled":false},{"id":"21456","alias":"win_dev","type":"collective","title":"Development for Windows","titleHtml":"Development for Windows","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Development","titleHtml":"Development"},{"id":"6","alias":"admin","title":"Administrating","titleHtml":"Administrating"}],"relatedData":null,"leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003ESetting up Atom for working with python is quite a tricky task. I've spent a lot of time making it work. Autocompleting, autoformatting, type hints, and much more will be available to you after reading this tutorial.\u003C\u002Fem\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa85\u002F882\u002F2b9\u002Fa858822b917a5ad7e76f2cea7b7a3e53.png","buttonTextHtml":"Open tutorial","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa85\u002F882\u002F2b9\u002Fa858822b917a5ad7e76f2cea7b7a3e53.png","fit":"cover","positionY":8.4090909090909,"positionX":49.358974358974}},"status":"published","plannedPublishTime":null,"checked":null}}},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{"begezavr":{"scoreStats":{"score":44.6,"votesCount":71},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"35523","alias":"begezavr","fullname":"Сергей Головин","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fdfb\u002Febc\u002F0ee\u002Fdfbebc0ee0ba41a25e30dd308bab1401.jpg","speciality":"Разработчик"}},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.1ca41abb.js" defer></script><script src="https://assets.habr.com/habr-web/js/chunk-f458c7c4.529673c8.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.132461d8.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
